#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el

* Load speedup
Load speed up:
#+BEGIN_SRC emacs-lisp
(let ((gc-cons-threshold most-positive-fixnum)
      (file-name-handler-alist nil))
#+END_SRC

* Setup
** Setup path correctly
#+BEGIN_SRC emacs-lisp
(defun set-exec-path-from-shell-PATH ()
  (interactive)
  (let ((path-from-shell
         (replace-regexp-in-string
          "^.*\n.*shell\n" ""
          (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
        (setenv "PATH" path-from-shell)
        (setq exec-path (split-string path-from-shell path-separator))))

(set-exec-path-from-shell-PATH)
#+END_SRC

** Personal information
Personal information is stored in personal.el.
This file must include personal information given as
> (setq user-full-name "MY NAME"
>       user-mail-address "MY EMAIL")
#+BEGIN_SRC emacs-lisp
(load "~/.dotfiles/personal.el")
#+END_SRC

** Setting up package manager and use-package
#+begin_src emacs-lisp
  ;; Please don't load outdated byte code
  (setq load-prefer-newer t)

  (require 'package)
  (setq package-enable-at-startup nil)

  (setq package-archives
        '(("gnu"         . "http://elpa.gnu.org/packages/")
          ("melpa" . "http://melpa.org/packages/" )))

  (package-initialize)

  ;; Bootstrap `use-package'
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
  (require 'bind-key)

  (use-package paradox
    :ensure t
    :commands paradox-list-packages)
#+end_src

** Some nice configurations
#+BEGIN_SRC emacs-lisp
(defun my-minibuffer-setup-hook ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun my-minibuffer-exit-hook ()
  (setq gc-cons-threshold 800000))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)

;; warn when opening files bigger than 100MB
(setq large-file-warning-threshold 100000000)

;; Make backups and auto saves to the same directory
(setq backup-directory-alist '(("." . "~/.EmacsBackups")))
(setq auto-save-file-name-transforms '((".*" "~/.EmacsSaves/" t)))
#+END_SRC

** Custom set variables
#+BEGIN_SRC emacs-lisp
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(custom-safe-themes
   (quote
    ("3c83b3676d796422704082049fc38b6966bcad960f896669dfc21a7a37a748fa" default)))
 '(paradox-github-token t)
 '(safe-local-variable-values
   (quote
    ((eval setq system-time-locale "es")
     (eval setq system-time-locale "C")
     (eval setq org-link-file-path-type 'relative)))))
#+END_SRC

* User interface
** Some nice configurations
#+BEGIN_SRC emacs-lisp
;;Start always maximized
(add-to-list 'default-frame-alist '(fullscreen . maximized))

;; Set scratch message
(setq initial-scratch-message nil)

;; Menus and bars.
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)

;;Disable blinking cursor and start up screen
(blink-cursor-mode -1)

;;Disable startup screen
(setq inhibit-startup-screen t)

;;Display column number.
(column-number-mode t)

;;Enable y/n answers
(fset 'yes-or-no-p 'y-or-n-p)

;;Show unfinished keystroke early
(setq echo-keystrokes 0.1)

;;Better frame title
(setq frame-title-format "%b")

;; Ignore system colors
(setq inhibit-x-resources 't)
#+END_SRC

** Font settings
#+BEGIN_SRC emacs-lisp
;; adjust font size to screen resolution
(if (display-graphic-p)
    (if (< (x-display-pixel-width) 1920)
        (set-face-attribute 'default nil :height 100)
      (set-face-attribute 'default nil :height 120)))
#+END_SRC

** Color theme
#+BEGIN_SRC emacs-lisp
   (load-theme 'darktooth t)
#+END_SRC

** Smart mode line
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :ensure t
  :config
  (setq rm-whitelist "Projectile")
  (sml/setup)
  (setq sml/name-width 30))
#+END_SRC

** Nice scrolling, not centering after scrolling.
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 0
      scroll-conservatively 10000
      scroll-preserve-screen-position 1)

(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq auto-window-vscroll nil)
#+END_SRC

* Utilities
** Crux
Here I bind the functions I find useful, there are more. See:
https://github.com/bbatsov/crux
#+BEGIN_SRC emacs-lisp
(use-package crux
  :ensure t
  :init
  (setq crux-indent-sensitive-modes
        '(conf-mode coffee-mode haml-mode
                    python-mode slim-mode yaml-mode org-mode))
  :bind
  (("C-c o" . crux-open-with)
  ("C-c D" . crux-delete-file-and-buffer)
  ("C-c r" . crux-rename-file-and-buffer)
  ("C-c k" . crux-kill-other-buffers)
  ("C-c n" . crux-cleanup-buffer-or-region)
  ("s-k" . crux-kill-line-backwards)
  ("C-M-z" . crux-indent-defun)
  ("C-`" . crux-switch-to-previous-buffer)
  ("C-c s" . crux-swap-windows)
  ("C-a" . crux-move-beginning-of-line)
  ("C-S-<return>" . crux-smart-open-line-above)
  ("S-<return>" . crux-smart-open-line))
  :commands crux-recompile-init
  :config
  (crux-with-region-or-buffer indent-region)
  (crux-with-region-or-buffer untabify))
#+END_SRC

** Function: fill-unfill-paragraph
#+BEGIN_SRC emacs-lisp
(defun fill-or-unfill ()
  "Like `fill-paragraph', but unfill if used twice."
  (interactive)
  (let ((fill-column
         (if (eq last-command 'fill-or-unfill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (call-interactively #'fill-paragraph)))

(global-set-key [remap fill-paragraph] #'fill-or-unfill)
#+END_SRC

** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t)
#+END_SRC

** Counsel
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer-other-window)
(use-package smex ;;provides history to counsel-M-x
  :ensure t)
(use-package counsel
  :ensure t
  :bind
  ("M-x" . counsel-M-x)
  ("C-s" . counsel-grep-or-swiper)
  ("M-y" . counsel-yank-pop)
  ("C-x C-f" . counsel-find-file)
  ("C-x C-r" . counsel-recentf)
  ("C-h v" . counsel-describe-variable)
  ("C-h f" . counsel-describe-function)
  ("<f2> u" . counsel-unicode-char)
  ("C-c g" . counsel-ag)
  ("C-c r" . ivy-resume)
  ("C-c i" . counsel-imenu)
  ("C-x b" . ivy-switch-buffer)
  ("C-x <left>" . counsel-mark-ring)
  ("C-x <right>" . counsel-mark-ring)
  :config
  (ivy-mode 1)
  (setq ivy-height 7)
  (setq ivy-count-format "(%d/%d) ")
  (setq ivy-initial-inputs-alist nil)
  (setq counsel-yank-pop-separator "\n--------------------------------------\n")
  (setq swiper-include-line-number-in-search t)
  (setq ivy-ignore-buffers
        '("\\` "
          "*Help*" "*scratch*" "*Messages*" "\\`\\*magit" "*toc*"
          "synctex.gz"))
  (setq ivy-re-builders-alist
        '((t . ivy--regex-ignore-order)))
  (ivy-add-actions 'counsel-find-file
                   '(("F" (lambda (x) (with-ivy-window (insert (file-relative-name x))))
                      "insert relative file name")
                     ("B" (lambda (x)
                            (with-ivy-window
                              (insert (file-name-nondirectory (replace-regexp-in-string "/\\'" "" x)))))
                      "insert file name without any directory information")))
  )
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(ivy-highlight-face ((t (:inherit minibuffer-prompt)))))
(use-package ivy-hydra
  :ensure t)
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind ("C-x g" . magit-status))
#+END_SRC

** Undo tree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :config
  (global-undo-tree-mode)
  (global-set-key (kbd "C-z") 'undo)
  (global-set-key (kbd "C-S-z") 'undo-tree-redo))
#+END_SRC

** Flyspell
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :config
  ;; use aspell instead of ispell
  (setq ispell-program-name "aspell"
        ispell-extra-args '("--sug-mode=ultra"))
  (add-hook 'text-mode-hook 'turn-on-flyspell)
  (setq flyspell-tex-command-regexp
        "\\(\\(begin\\|end\\)[  ]*{\\|\\(cite[a-z*]*\\|label\\|ref\\|eqref\\|usepackage\\|documentclass\\|bibliographystyle\\)[         ]*\\(\\[[^]]*\\]\\)?{[^{}]*\\)")
)

(use-package flyspell-correct-popup
  :ensure t
  :config
  (define-key
    flyspell-mode-map (kbd "C-;") #'flyspell-correct-previous-word-generic))
#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (global-set-key (kbd "s-ยบ") 'company-complete)
  (add-hook 'after-init-hook 'global-company-mode))

(use-package company-c-headers
  :ensure t
  :config
  (add-to-list 'company-backends 'company-c-headers))

(use-package company-auctex
  :defer t
  :ensure t)

(use-package company-math
  :ensure t
  :config
  (add-to-list 'company-backends 'company-math-symbols-unicode))

(defun my-company-latex-mode-setup ()
  (setq-local company-backends
              (append '(company-auctex-labels
                        company-auctex-bibs
                        (company-math-symbols-latex
                         company-auctex-macros
                         company-auctex-environments)
                        )
                      company-backends)))
(add-hook 'LaTeX-mode-hook 'my-company-latex-mode-setup)

;; Company for org-mode. Org-mode uses pcomplete for it's own
;; completion. We add it to the capf backend.
(defun add-pcomplete-to-capf ()
  (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
(add-hook 'org-mode-hook #'add-pcomplete-to-capf)
#+END_SRC

** Deft
[[https://github.com/jrblevin/deft][Deft]] is an Emacs mode for quickly browsing, filtering, and editing
directories of plain text notes, inspired by Notational Velocity. It
was designed for increased productivity when writing and taking notes
by making it fast and simple to find the right file at the right time
and by automating many of the usual tasks such as creating new files
and saving files.

#+BEGIN_SRC emacs-lisp
(use-package deft
  :ensure t
  :bind ("<f8>" . deft)
  :commands (deft)
  :config
  (setq deft-directory "~/Documents/Notes"
        deft-extensions '("org" "tex"))
  (setq deft-default-extension "org")
  (setq deft-use-filter-string-for-filename t)
  (setq deft-file-naming-rules
        '((noslash . "-")
          (nospace . "-")
          (case-fn . downcase))))
#+END_SRC

** Function: open-term-here
A function for opening an external terminal emulator in the current
path.

#+BEGIN_SRC emacs-lisp
(defun open-term-here ()
  (interactive)
  "Open a terminal in current buffer's path."
  (call-process
   "konsole"
   nil 0 nil
   (concat "--workdir="
           (file-name-directory (or load-file-name buffer-file-name)))))
(global-set-key (kbd "C-c t") 'open-term-here)
#+END_SRC

** Save recent files
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :config
  (setq recentf-save-file (expand-file-name "recentf" "~/.emacs.d/savefile/")
        recentf-max-saved-items 50
        ;; disable recentf-cleanup on Emacs start, because it can cause
        ;; problems with remote files
        recentf-auto-cleanup 'never)

  (defun prelude-recentf-exclude-p (file)
    "A predicate to decide whether to exclude FILE from recentf."
    (let ((file-dir (file-truename (file-name-directory file))))
      (-any-p (lambda (dir)
                (string-prefix-p dir file-dir))
              (mapcar 'file-truename (list "~/.emacs.d/savefile/" "~/.emacs.d/elpa/")))))

  (add-to-list 'recentf-exclude 'prelude-recentf-exclude-p)
  (add-to-list 'recentf-exclude "COMMIT_EDITMSG\\'")
  (add-to-list 'recentf-exclude "\\.png\\'")
  (add-to-list 'recentf-exclude "\\org-clock-save.el\\'")
  (add-to-list 'recentf-exclude "\\.gz\\'")
  (add-to-list 'recentf-exclude "\\.log\\'")
  (add-to-list 'recentf-exclude "\\.orhc-bibtex-cache\\'")

  (recentf-mode +1))
#+END_SRC

** Yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config
  (setq yas-snippet-dirs
        '("~/.dotfiles/snippets"
          yas-installed-snippets-dir))
  (yas/global-mode 1)
  (define-key yas-minor-mode-map (kbd "s-<tab>") 'yas-expand)
  (define-key yas-minor-mode-map [(tab)]        nil)
  (define-key yas-minor-mode-map (kbd "TAB")    nil)
  (define-key yas-minor-mode-map (kbd "<tab>")  nil))
#+END_SRC

** Ivy-bibtex
#+BEGIN_SRC emacs-lisp
(use-package ivy-bibtex
  :ensure t
  :config
  (setq bibtex-completion-bibliography
        '("/home/gperaza/Documents/SortedResources/bibliography.bib"))
  (setq bibtex-completion-pdf-field "file")
  (setq bibtex-completion-notes-path
        "/home/gperaza/Documents/SortedResources/Notes"))
#+END_SRC

** TODO Outshine and outorg
#+BEGIN_SRC emacs-lisp
(use-package outshine
  :ensure t
  :init
  (defvar outline-minor-mode-prefix "\M-#")
  :config
  ;;(add-hook 'outline-minor-mode-hook 'outshine-hook-function)
  (add-hook 'emacs-lisp-mode-hook 'outline-minor-mode)
  ;; Structure editing
  (define-key outline-minor-mode-map
    (kbd "<S-iso-lefttab>") 'outshine-cycle-buffer)
  (define-key outline-minor-mode-map
    (kbd "<S-up>") 'outline-move-subtree-up)
  (define-key outline-minor-mode-map
    (kbd "<S-down>") 'outline-move-subtree-down)
  (define-key outline-minor-mode-map
    (kbd "<S-right>") 'outline-demote)
  (define-key outline-minor-mode-map
    (kbd "<S-left>") 'outline-promote))
  ;; Navigation TODO)
#+END_SRC

* Editing configuration
** Some general editing configurations
#+BEGIN_SRC emacs-lisp
;; always follow symlinks of vc files
(setq vc-follow-symlinks t)

;; don't use tabs to indent
(setq-default indent-tabs-mode nil)

;; Require new line at the end of a file
(setq require-final-newline t)

;;Delete selection when copying/writing on top
(delete-selection-mode t)

;;Auto revert files
(global-auto-revert-mode t)

;;Enable narrowing commands
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-defun 'disabled nil)

;;Enable erase-buffer command
(put 'erase-buffer 'disabled nil)

;; Make ediff use one frame
(setq ediff-window-setup-function 'ediff-setup-windows-plain)

;;Treat camel case words (camelCase) as separate words.
(global-subword-mode 1)

;;Allow typing TeX characters after toggling the input method with C-\
(setq default-input-method 'TeX)

;;Remember location in a file when saving
(require 'saveplace)
(setq-default save-place t)
;; For emacs 25 do (save-place-mode 1)

;; Turn on auto fill
(add-hook 'text-mode-hook 'turn-on-auto-fill)

;; Set truncate lines to nil
(set-default 'truncate-lines t)

;;Set fill column
(setq-default fill-column 80)

;; Save whateverโs in the current (system) clipboard before
;; replacing it with the Emacsโ text.
(setq save-interprogram-paste-before-kill t)
#+END_SRC

** White space mode
#+BEGIN_SRC emacs-lisp
(setq whitespace-line-column 80)
(setq whitespace-style '(face trailing lines-tail))
(add-hook 'prog-mode-hook 'whitespace-mode)
(add-hook 'LaTeX-mode-hook 'whitespace-mode)
#+END_SRC

** Zzz-to-char (kills from current point to character, M-z/M-Z)
#+BEGIN_SRC emacs-lisp
(use-package zzz-to-char
  :ensure t
  :config
  (global-set-key (kbd "M-z") 'zzz-up-to-char)
  (global-set-key (kbd "M-Z") 'zzz-to-char))
#+END_SRC

** Move lines or region up and down
To imitate move lines outside org mode.
#+BEGIN_SRC emacs-lisp
(use-package move-text
  :ensure t
  :config
  (global-set-key (kbd "M-S-<up>")  'move-text-up)
  (global-set-key (kbd "M-S-<down>") 'move-text-down))
#+END_SRC

** Volatile highlights, highlight things like undo, copy, etc.
#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :ensure t
  :config (volatile-highlights-mode t))
#+END_SRC

** Make C-w/M-w kill/copy single line when not selection is active
#+BEGIN_SRC emacs-lisp
;; note - this should be after volatile-highlights is required
(defadvice kill-region (before smart-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(use-package easy-kill
  :ensure t
  :config
  (global-set-key [remap kill-ring-save] 'easy-kill)
  (global-set-key [remap mark-sexp] 'easy-mark))
#+END_SRC

** Expand region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("M-2" . er/expand-region))
#+END_SRC

** Automatically indent yanked text in programming modes
#+BEGIN_SRC emacs-lisp
(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) 1000)
      (indent-region beg end nil)))

(defcustom prelude-yank-indent-modes '(LaTeX-mode TeX-mode)
  "Modes in which to indent regions that are yanked (or yank-popped).
      Only modes that don't derive from `prog-mode' should be listed here."
  :type 'list
  :group 'prelude)

(defmacro advise-commands (advice-name commands class &rest body)
  "Apply advice named ADVICE-NAME to multiple COMMANDS.
      The body of the advice is in BODY."
  `(progn
     ,@(mapcar (lambda (command)
                 `(defadvice ,command (,class ,(intern (concat (symbol-name command) "-" advice-name)) activate)
                    ,@body))
               commands)))

(advise-commands "indent" (yank yank-pop) after
                 "If current mode is one of `prelude-yank-indent-modes',
      indent yanked text (with prefix arg don't indent)."
                 (if (and (not (ad-get-arg 0))
                          (not (member major-mode crux-indent-sensitive-modes))
                          (or (derived-mode-p 'prog-mode)
                              (member major-mode prelude-yank-indent-modes)))
                     (let ((transient-mark-mode nil))
                       (yank-advised-indent-function (region-beginning) (region-end)))))
#+END_SRC

** Compilation
Let's customize the behavior of the compilation process. We always to
save when compiling, no need to ask. Also, if a previous compilation
process exists, kill it before starting a new one. Finally,
automatically scroll to first error.

We can interpret the ansi color escape codes to colorize the
compilation buffer. For this we follow Malabarba's [[http://endlessparentheses.com/ansi-colors-in-the-compilation-buffer-output.html?source=rss][advice]].

Also, automatically close the compilation buffer when compilation
succeeds without error.

#+BEGIN_SRC emacs-lisp
(require 'compile)
(setq compilation-ask-about-save nil
      compilation-always-kill t
      compilation-scroll-output 'first-error)

(require 'ansi-color)
(defun endless/colorize-compilation ()
  "Colorize from `compilation-filter-start' to `point'."
  (let ((inhibit-read-only t))
    (ansi-color-apply-on-region
     compilation-filter-start (point))))

(add-hook 'compilation-filter-hook
          #'endless/colorize-compilation)

(defun bury-compile-buffer-if-successful (buffer string)
  "Bury a compilation buffer if succeeded without warnings "
  (if (and
       (string-match "compilation" (buffer-name buffer))
       (string-match "finished" string)
       (not
        (with-current-buffer buffer
          (goto-char (point-min))
          (search-forward "warning" nil t))))
      (run-with-timer 1 nil 'winner-undo)))
(add-hook 'compilation-finish-functions 'bury-compile-buffer-if-successful)
#+END_SRC

** Hungry delete
#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
:ensure t
:bind (("s-<backspace>" . hungry-delete-backward)
       ("s-<delete>" . hungry-delete-forward)))
#+END_SRC

** Multiple Cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t)
#+END_SRC
* Navigation
** Misc
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
(global-set-key (kbd "C-x w") 'kill-buffer-and-window)
#+END_SRC

** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind
  (("M-l" . avy-goto-line)
   ("M-s" . avy-goto-word-or-subword-1)))
#+END_SRC

** Windmove to move between visible buffers
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :bind
  (("s-<right>" . windmove-right)
   ("s-<left>" . windmove-left)
   ("s-<up>" . windmove-up)
   ("s-<down>" . windmove-down)
   ))
#+END_SRC

** Winner mode, undo-redo window configuration
#+BEGIN_SRC emacs-lisp
(use-package winner
  :config (winner-mode 1))
#+END_SRC

* LaTeX
#+BEGIN_SRC emacs-lisp
(use-package tex
  :ensure auctex
  :config
  (setq-default TeX-master nil)
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq TeX-electric-math (cons "$" "$"))

  ;;Use pdf-tools to open PDF files
  (setq TeX-view-program-selection '((output-pdf "Okular"))
        TeX-source-correlate-start-server t)
  ;;Update PDF buffers after successful LaTeX runs
  ;; (add-hook 'TeX-after-compilation-finished-functions
  ;;           'TeX-revert-document-buffer)

  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (outline-minor-mode t)
              (flyspell-mode t)
              ;;(TeX-PDF-mode -1)
              (TeX-fold-mode t)
              (turn-on-reftex)
              (TeX-source-correlate-mode t)
              (setq TeX-command-extra-options "--shell-escape")
              (LaTeX-math-mode t)))

  ;; reftex settings
  (setq reftex-enable-partial-scans t)
  (setq reftex-use-multiple-selection-buffers t)
  (setq reftex-plug-into-AUCTeX t)

  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (setq outline-promotion-headings
                    '("\\chapter" "\\section" "\\subsection"
                      "\\subsubsection" "\\paragraph" "\\subparagraph"))))
  ;; extra outline headers

  (setq LaTeX-section-list
        '(("chapter" 1)
          ("section" 2)
          ("subsection" 3)
          ("subsubsection" 4)
          ("paragraph" 5)
          ("subparagraph" 6)))

  (setq TeX-outline-extra
        '(("\\\\begin{frame}" 5)
          ("\\\\question" 5)
          (" *\\\\part" 6))
        )
  )
#+END_SRC

* org-mode
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure t
  :pin gnu)
#+END_SRC

** Appearance
Here we make org buffers look nice. Only affects visuals.

Change the ellipsis at the end of collapsed nodes and replace the
asterisks at the beginning of headings with nicer symbols:

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " โผ")
(use-package org-bullets
    :ensure t)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

This hides the markup markers (* for bold. / for emphasis, etc.), they
are still there, just hidden:

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

We change the "-" in lists to nice bullets:

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 '(("^ +\\([-*]\\) "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "โข"))))))
#+END_SRC

I like to keep text width under 80 characters. Indentation in lower
level headings makes things look weird so we disable indentation all
together.

#+BEGIN_SRC emacs-lisp
(setq org-adapt-indentation nil)
#+END_SRC

Make code blocks pretty:

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

Increase the size of and colorize latex fragments in text:

#+BEGIN_SRC emacs-lisp
(plist-put org-format-latex-options :scale 1.5)

(eval-after-load 'org
  '(setf org-highlight-latex-and-related '(latex)))
#+END_SRC

Enable display of pretty entities by default. This makes text like
~\ mu~ as \mu.
#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities t)
#+END_SRC

Start with contents displayed
#+BEGIN_SRC emacs-lisp
(setq org-startup-folded 'content)
#+END_SRC

** Babel, code inside org
Babel is Org-mode's ability to execute source code within Org-mode
documents.

*** Enable languages
First we need to tell babel which languages we intend to use, we can
add more later.

#+BEGIN_SRC emacs-lisp
(require 'ob-shell)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (sh . t)
   (org . t)
   (C . t)
   (latex . t)
   (awk . t)
   (gnuplot . t)))
#+END_SRC

*** Set up Babel behavior
Don't ask for confirmation when evaluating a code block.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil
      org-confirm-elisp-link-function nil
      org-confirm-shell-link-function nil)
#+END_SRC

I generally have huge and slow code blocks, we don't want to evaluate
this on export. Also, being huge better keep them folded at startup.

#+BEGIN_SRC emacs-lisp
(setq org-export-babel-evaluate nil)
(setq org-hide-block-startup t)
#+END_SRC

Code block indentation messes up indent sensitive languages like
Python, disable it. While we are messing with indentation let's make
tab behave as in the native major mode inside blocks.

#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)
(setq org-src-tab-acts-natively t)
#+END_SRC

Export both code and results.

#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args
      (cons '(:exports . "both")
            (assq-delete-all :exports org-babel-default-header-args)))
#+END_SRC

Disable Flycheck when editing code blocks.
#+BEGIN_SRC emacs-lisp
(defun disable-flycheck-in-org-src-block ()
  (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
(add-hook 'org-src-mode-hook 'disable-flycheck-in-org-src-block)
#+END_SRC 

*** Wrap text in a code block
Sometimes I need to wrap some text inside a code block, specially for
LaTeX code. I don't remember where I find this but it is useful.

#+BEGIN_SRC emacs-lisp
(defun org-begin-template ()
  "Make a template at point."
  (interactive)
  (if (org-at-table-p)
      (call-interactively 'org-table-rotate-recalc-marks)
    (let* ((choices '(("s" . "SRC")
                      ("e" . "EXAMPLE")
                      ("q" . "QUOTE")
                      ("v" . "VERSE")
                      ("c" . "CENTER")
                      ("l" . "LaTeX")
                      ("h" . "HTML")
                      ("a" . "ASCII")))
           (key
            (key-description
             (vector
              (read-key
               (concat (propertize "Template type: " 'face 'minibuffer-prompt)
                       (mapconcat (lambda (choice)
                                    (concat (propertize (car choice) 'face 'font-lock-type-face)
                                            ": "
                                            (cdr choice)))
                                  choices
                                  ", ")))))))
      (let ((result (assoc key choices)))
        (when result
          (let ((choice (cdr result)))
            (cond
             ((region-active-p)
              (let ((start (region-beginning))
                    (end (region-end)))
                (goto-char end)
                (insert "#+END_" choice "\n")
                (goto-char start)
                (insert "#+BEGIN_" choice "\n")))
             (t
              (insert "#+BEGIN_" choice "\n")
              (save-excursion (insert "#+END_" choice))))))))))

;;bind to key
(define-key org-mode-map (kbd "C-<") 'org-begin-template)
#+END_SRC

** Editing
Configuration of some ways to write in org.

*** Footnotes
In-line and still reference-able footnote definitions. Footnotes have
random unique id's and being inline means it is difficult to mess up
references by deleting stuff.

#+BEGIN_SRC emacs-lisp
(setq org-footnote-define-inline t)
(setq org-footnote-auto-label 'random)
(setq org-footnote-auto-adjust nil)
#+END_SRC

*** Lists
Allow lists with letters in them.

#+BEGIN_SRC emacs-lisp
(setq org-list-allow-alphabetical t)
#+END_SRC

** Structure editing
*** Refile and copy
When reviewing the captured data, you may want to refile or to copy
some of the entries into a different list, for example into a
project. Cutting, finding the right location, and then pasting the
note is cumbersome. To simplify this process, you can use the
refile command ~C-c C-w~. But first we need to configure it to target
down to level 3 headings and use path like selection:

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((nil . (:maxlevel . 3))))
(setq org-refile-use-outline-path t)
(setq org-outline-path-complete-in-steps nil)
#+END_SRC

** Org mode links
Enable storing, inserting and following links in any buffer:

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-cL" 'org-insert-link-global)
(global-set-key "\C-co" 'org-open-at-point-global)

(setq org-file-apps
      '((auto-mode . emacs)
        ("\\.mm\\'" . default)
        ("\\.x?html?\\'" . "google-chorme %s")
        ("\\.pdf\\'" . default)
        ("\\.png\\'" . "pqiv -i %s")
        ("\\.jpg\\'" . "pqiv -i %s")
        ("\\.svg\\'" . "feh --magick-timeout 1 -. %s")))
#+END_SRC

Custom link types:

#+BEGIN_SRC emacs-lisp
;; Define a link to a YouTube video as defined in
;; http://endlessparentheses.com/embedding-youtube-videos-with-org-mode-links.html
(defvar yt-iframe-format
  ;; You may want to change your width and height.
  (concat "<iframe width=\"440\""
          " height=\"335\""
          " src=\"https://www.youtube.com/embed/%s\""
          " frameborder=\"0\""
          " allowfullscreen>%s</iframe>"))

(org-add-link-type
 "yt"
 (lambda (handle)
   (browse-url
    (concat "https://www.youtube.com/embed/"
            handle)))
 (lambda (path desc backend)
   (cl-case backend
     (html (format yt-iframe-format
                   path (or desc "")))
     (latex (format "\href{%s}{%s}"
                    path (or desc "video"))))))

;; Open link path in a terminal
(org-add-link-type "dir+term" 'org-dir-term-open)

(defun org-dir-term-open (path)
  "Open PATH in a terminal."
  (call-process "konsole"
                nil 0 nil
                (concat "--default-working-directory="
                        (expand-file-name path))))

(defun org-dir+term-complete-link (&optional arg)
  "Create a dir link using completion."
  (let ((file (org-iread-file-name "File: "))
        (pwd (file-name-as-directory (expand-file-name ".")))
        (pwd1 (file-name-as-directory (abbreviate-file-name
                                       (expand-file-name ".")))))
    (cond ((equal arg '(16))
           (concat "dir+term:"
                   (abbreviate-file-name (expand-file-name file))))
          ((string-match
            (concat "^" (regexp-quote pwd1) "\\(.+\\)") file)
           (concat "dir+term:" (match-string 1 file)))
          ((string-match
            (concat "^" (regexp-quote pwd) "\\(.+\\)")
            (expand-file-name file))
           (concat "dir+term:"
                   (match-string 1 (expand-file-name file))))
          (t (concat "dir+term:" file)))))
#+END_SRC

** Navigation
Enable fast navigation on headers. To see a list of available commands
press ? with the cursor at the beginning of a headline.

#+BEGIN_SRC emacs-lisp
(setq org-use-speed-commands t)
#+END_SRC

A hydra to navigate when not in a heading. Useful when I don't
remember the commands. Now includes the useful ~org-toc-show~ to show a
table of contents.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org (:color red :columns 3)
  "Org Mode Movements"
  ("n" outline-next-visible-heading "next heading")
  ("p" outline-previous-visible-heading "prev heading")
  ("N" org-forward-heading-same-level "next heading at same level")
  ("P" org-backward-heading-same-level "prev heading at same level")
  ("u" outline-up-heading "up heading")
  ("g" org-goto "goto" :exit t)
  ("t" org-toc-show "TOC" :exit t))

(define-key org-mode-map (kbd "s-n") 'hydra-org/body)
#+END_SRC

Set some org-toc properties, activate follow mode:
#+BEGIN_SRC emacs-lisp
(setq org-toc-follow-mode t)
#+END_SRC

Function that replaces the entire key map for narrow widen in org.
Narrowing is really useful to focus only on the relevant section we
want to edit. Now we can narrow/widen smartly using only
C-x n. Works globally, not only in org-mode, perhaps I should move
this elsewhere.

#+BEGIN_SRC emacs-lisp
(defun latex-narrow-to-section ()
  "Narrow to current section"
  (LaTeX-mark-section)
  (call-interactively 'narrow-to-region)
  (deactivate-mark))

(defun latex-on-section-header ()
  "Return non-nil if point is on a section header."
  (if (string-match "\\`\\\\\\(sub\\)*section{.*}" (thing-at-point 'line t))
       t nil))

(defun narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning)
                           (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing
         ;; command. Remove this first conditional if
         ;; you don't want it.
         (cond ((ignore-errors (org-edit-src-code) t)
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        ((derived-mode-p 'latex-mode)
         (if (latex-on-section-header)
             (latex-narrow-to-section)
           (LaTeX-narrow-to-environment)))
        (t (narrow-to-defun))))

;; This line actually replaces Emacs' entire narrowing
;; keymap, that's how much I like this command. Only
;; copy it if that's what you want.
(define-key ctl-x-map "n" #'narrow-or-widen-dwim)
(add-hook 'LaTeX-mode-hook
          (lambda ()
            (define-key LaTeX-mode-map "\C-xn"
              nil)
            (define-key LaTeX-mode-map "\C-ci" 'counsel-outline)
            ))
#+END_SRC

** Org mode exporter
Org-mode allow us to export our document to different formats. The two
I use the most are LaTeX and HTML.

*** Export back-ends
Enable back-ends for export formats. Aside from LaTeX and HTML, beamer
is to make presentations, koma-letter is a LaTeX class for letters and
ox-bibtex handles citations in HTML exports, for LaTeX citations I use
[[*Org-ref][org-ref]].

#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(require 'ox-html)
#+END_SRC

**** LaTeX back-end configuration
The LaTeX back-end needs some extra configuration.

Define extra packages to be included in latex exports.

#+BEGIN_SRC emacs-lisp
(setq org-latex-packages-alist
      '(("" "lmodern" nil);; latin modern fonts
        ("" "mathtools" t);; superseeds amsmath
        ("" "url" nil);; enable \url{} for urls
        ("" "color" nil)
        ("" "amssymb" nil)
        ("" "amsopn" nil)
        ("" "nicefrac" nil)
        ("" "units" nil)
        ("" "gensymb" nil)
        ))
#+END_SRC

To enable syntax highlighting for source code in LaTeX export we need
pygmentize installed. Currently it's disabled because it breaks
portability with standard LaTeX work flows, particularly my
collaborators don't know how to compile a tex file with this enabled.
It can be enables in each buffer by manually including the minted
package via "#+LATEX_HEADER: /usepackage{minted}"

#+BEGIN_SRC emacs-lisp
;; Add minted to the defaults packages to include when exporting.
;;(add-to-list 'org-latex-packages-alist '("" "minted" nil))

;; Tell the latex export to use the minted package for source code
;; coloration.
(setq org-latex-listings 'minted)

;; Let the exporter use the -shell-escape option to let latex execute
;; external programs. This obviously and can be dangerous to activate!
(setq org-latex-minted-options
      '(("mathescape" "true")
        ("linenos" "true")
        ("numbersep" "5pt")
        ("frame" "lines")
        ("framesep" "2mm")))
(setq org-latex-pdf-process
      '("latexmk -pdflatex='pdflatex --shell-escape' -pdf %f"))
#+END_SRC

*** Export behavior
I want to interpret "_" and "^" as sub and super indices only when
braces are used.

#+BEGIN_SRC emacs-lisp
(setq org-export-with-sub-superscripts '{})
#+END_SRC

If org-export-allow-bind-keywords is non-nil, Emacs variables can
become buffer-local during export by using the BIND keyword. Its
syntax is โ#+BIND: variable valueโ. This is particularly useful for
in-buffer settings that cannot be changed using specific keywords.

#+BEGIN_SRC emacs-lisp
(setq org-export-allow-bind-keywords t)
#+END_SRC

Sometimes I want a header to be ignored but the content to be
exported, for this we activate ignore-headlines from ox-extra.
Now the tag "ignore" does just this.

#+BEGIN_SRC emacs-lisp
;;(require 'ox-extra)
;;(ox-extras-activate '(ignore-headlines))
#+END_SRC

** Templates
*** General purpose
This is a template for a research/project aid document. The purpose of
this document is to hold task, reading list, and some quick
notes. It's available using the "<paper" expansion.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             `("paper"
               ,(concat
                "#+TITLE:\n"
                "#+DATE:\n"
                "#+PROPERTY: cookie_data recursive\n\n"
                "Description:\n\n"
                "* Files\n"
                "* Tasks\n"
                "** Writing\n"
                "** Modeling\n"
                "** Simulations\n"
                "* Reading\n"
                "** Must read\n"
                "** Should read\n"
                "** Already read and relevant\n"
                "** Already read and not relevant\n"
                "* Meetings\n")))
#+END_SRC

*** Code block templates
Templates for fast insertion of code blocks in org.
 - ~<p~ for python
 - ~<po~ for python with :results output
 - ~<pv~ for python with :results value output
 - ~<el~ for emacs-lisp
 - ~<sh~ for shell
 - ~<l~ for LaTeX
   
#+BEGIN_SRC emacs-lisp
;; add <p for python expansion
(add-to-list 'org-structure-template-alist
             '("p"
               "#+BEGIN_SRC python\n?\n#+END_SRC"
               "<src lang=\"python\">\n?\n</src>"))

;; add <por for python expansion with raw output
(add-to-list 'org-structure-template-alist
             '("po"
               "#+BEGIN_SRC python :results output raw\n?\n#+END_SRC"
               "<src lang=\"python\">\n?\n</src>"))

;; add <pv for python expansion with value
(add-to-list 'org-structure-template-alist
             '("pv"
               "#+BEGIN_SRC python :results value\n?\n#+END_SRC"
               "<src lang=\"python\">\n?\n</src>"))

;; add <el for emacs-lisp expansion
(add-to-list 'org-structure-template-alist
             '("el"
               "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"
               "<src lang=\"emacs-lisp\">\n?\n</src>"))

;; add <sh for shell
(add-to-list 'org-structure-template-alist
             '("sh"
               "#+BEGIN_SRC sh\n?\n#+END_SRC"
               "<src lang=\"shell\">\n?\n</src>"))

;; add <l for latex
(add-to-list 'org-structure-template-alist
             '("l"
               "#+BEGIN_LATEX latex\n?\n#+END_LATEX"
               "<src lang=\"latex\">\n?\n</src>"))
#+END_SRC

*** Blogging
This is post template. To create a blog post in it's own org file.
Accesses by ~<bpost~.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             `("bpost" ,(concat "#+TITLE: ?\n"
"#+DATE:\n"
"#+SUBTITLE: Posted:\n"
"# #+SUBTITLE: (/Last edited: {{{modification-time(%d %b %Y %H:%M)}}}/ )\n"
"#+AUTHOR: " user-full-name "\n"
"#+EMAIL: " user-mail-address "\n"
"#+LANGUAGE: en\n\n\n\n"
"* COMMENT local variables for this file
# Local Variables:
# eval: (setq system-time-locale \"en\")
# ispell-local-dictionary: \"en\"
# End:"
)))
#+END_SRC

This template creates a post preview. It's meant to be inserted in the
blog main page as a to-do heading. When the post is done mark is as
DONE to be published. Contains a summary of the post. Accessed by
~<bprev~.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             '("bprev" "* TODO ?
:DATES:
Posted:
# (/Edited: /)
:END:"))
#+END_SRC

** Blog using org publish
*** Formatting functions and variables
This function removes brackets for time stamps.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-export-filter-timestamp-functions
             #'endless/filter-timestamp)

(defun endless/filter-timestamp (trans back _comm)
  "Remove <> around time-stamps."
  (pcase back
    ((or `jekyll `html)
     (replace-regexp-in-string "&[lg]t;" "" trans))
    (`latex
     (replace-regexp-in-string "[<>]" "" trans))))
#+END_SRC

Here I define the format for displaying time stamps.

#+BEGIN_SRC emacs-lisp
(setq-default org-display-custom-times t)

;;; Before you ask: No, removing the <> here doesn't work.
(setq org-time-stamp-custom-formats
      '("<%d %b %Y>" . "<%d/%m/%y %a %H:%M>"))
#+END_SRC

This function creates the bibliography HTML file that is included in
the Research page.

#+BEGIN_SRC emacs-lisp
(defun my-bibtex-function ()
  (shell-command-to-string
   (concat "bibtex2html -d -r -nobibsource -nokeywords "
           "-nf arxiv \"Arxiv\" --revkeys -nodoc "
           "-m ~/Blog/macros.tex -s ~/Blog/owens_web "
           "-noheader -nofooter ~/Blog/mypubs.bib; "
           "echo \"#+BEGIN_HTML\" > ~/Blog/mypubs.in; "
           "cat ~/Blog/mypubs.html >> ~/Blog/mypubs.in; "
           "echo  \"\" >> ~/Blog/mypubs.in; "
           "echo \"#+END_HTML\" >> ~/Blog/mypubs.in")))
#+END_SRC

This function is used to format a drawer in HTML export. It adds the
drawer name as a class.

#+BEGIN_SRC emacs-lisp
(defun my-blog-org-export-format-drawer (name content)
  (concat "<div class=\"drawer " (downcase name) "\">\n"
          content
          "\n</div>"))
#+END_SRC

*** Project configuration
#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :ensure t)
(setq org-html-htmlize-output-type 'css)
#+END_SRC
    
* Programming
** Parenthesis
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(electric-pair-mode 1)

(use-package rainbow-delimiters
  :ensure t
  :config
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

(use-package wrap-region
  :ensure t
  :config
  (wrap-region-add-wrapper "$" "$" nil 'LaTeX-mode)
  (wrap-region-global-mode t))
#+END_SRC

** Comments
#+BEGIN_SRC emacs-lisp
(defun comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode 1))
(add-hook 'prog-mode-hook 'comment-auto-fill)

(defun xah-comment-dwim ()
  "Like `comment-dwim', but toggle comment if cursor is not at end of line.
URL `http://ergoemacs.org/emacs/emacs_toggle_comment_by_line.html'
Version 2016-10-25"
  (interactive)
  (if (region-active-p)
      (comment-dwim nil)
    (let ((-lbp (line-beginning-position))
          (-lep (line-end-position)))
      (if (eq -lbp -lep)
          (progn
            (comment-dwim nil))
        (if (eq (point) -lep)
            (progn
              (comment-dwim nil))
          (progn
            (comment-or-uncomment-region -lbp -lep)
            (forward-line )))))))
(global-set-key (kbd "M-;") 'xah-comment-dwim)
#+END_SRC

** Highlight comment annotations
#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :ensure t
  :config (add-hook 'prog-mode-hook 'hl-todo-mode))
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :config (global-flycheck-mode 1))

(use-package flycheck-pos-tip
  :ensure t
  :config
  (with-eval-after-load 'flycheck
    (flycheck-pos-tip-mode)))
#+END_SRC

** Clean-aindent-mode
#+BEGIN_SRC emacs-lisp
(use-package clean-aindent-mode
  :ensure t
  :config
  (add-hook 'prog-mode-hook 'clean-aindent-mode)
  (define-key prog-mode-map (kbd "RET") 'newline-and-indent))
#+END_SRC

** Semantic mode
Semantic mode enables parsing of source code files.
#+BEGIN_SRC emacs-lisp
(require 'semantic)

(global-semanticdb-minor-mode 1)
(global-semantic-idle-scheduler-mode 1)
(use-package stickyfunc-enhance
  :ensure t
  :init (global-semantic-stickyfunc-mode 1))
(semantic-mode 1)

(defun my/semantic-show-summary (point)
  "Display a summary for the symbol under POINT."
  (interactive "P")
  (let* ((ctxt (semantic-analyze-current-context point))
         (pf (when ctxt
               (semantic-analyze-interesting-tag ctxt)))
        )
    (if pf
        (popup-tip (format "%s" (semantic-format-tag-summarize pf nil t)))
      (popup-tip "No summary info available"))))
(define-key semantic-mode-map (kbd "s-i") 'my/semantic-show-summary)
(define-key semantic-mode-map (kbd "s-j") 'semantic-ia-fast-jump)
#+END_SRC

** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :init (setq projectile-use-git-grep t)
  :config
  (setq projectile-completion-system 'ivy)
  (projectile-global-mode))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
(use-package anaconda-mode
  :ensure t
  :config
  (add-hook 'python-mode-hook 'anaconda-mode)
  (add-hook 'python-mode-hook 'anaconda-eldoc-mode)
  (when (executable-find "ipython") (setq python-shell-interpreter "ipython")))
(use-package company-anaconda
  :ensure t
  :config
  (eval-after-load "company"
    '(add-to-list 'company-backends 'company-anaconda)))
#+END_SRC

** C
#+BEGIN_SRC emacs-lisp
(setq-default c-basic-offset 4)
(require 'cc-mode)

;; New functions
(define-key c-mode-base-map (kbd "RET") 'newline-and-indent)

(defun my/c-compile()
  (interactive)
  (compile "make -k"))
(define-key c-mode-base-map (kbd "<f5>") 'my/c-compile)

;; c99 mode
(defun my-flycheck-c-setup ()
  (setq flycheck-gcc-language-standard "gnu99"))
(add-hook 'c-mode-hook #'my-flycheck-c-setup)

;; function args mode
(use-package function-args
  :ensure t
  :config (fa-config-default))
#+END_SRC

** Gnuplot
#+BEGIN_SRC emacs-lisp
(use-package gnuplot-mode
  :ensure t)
  ;; :config
  ;; (add-to-list 'auto-mode-alist '("\\.gp\\'" . gnuplot-mode)))
#+END_SRC

** Processing
#+BEGIN_SRC emacs-lisp
(use-package processing-mode
  :ensure t
  :config
  (setq processing-location "/opt/processing/processing-java")
  (setq processing-application-dir "/opt/processing/")
  (setq processing-sketchbook-dir "/home/gperaza/Documents/code/processing/"))

;;Define a hydra with the basic processing commands.
(defhydra hydra-processing ()
    "Processing"
    ("r" processing-sketch-run "Run sketch.")
    ("b" processing-sketch-build "Compile sketch.")
    ("p" processing-sketch-present "Run sketch full screen.")
    ("e" processing-export-application "Export sketch.")
    ("d" processing-find-in-reference "Find in reference.")
    ("f" processing-find-sketch "Find or create sketch.")
    ("s" processing-search-forums "Search forum.")
    ("l" processing-open-examples "Open examples.")
    ("h" processing-open-reference "Open examples.")
    ("o" processing-open-sketchbook "Open sketchbook.")
    ("q" nil "quit"))

(define-key processing-mode-map (kbd "s-h") 'hydra-processing/body)

#+END_SRC

** Hide-show
#+BEGIN_SRC emacs-lisp
(add-hook
 'c-mode-common-hook (lambda()
                       (local-set-key (kbd "C-<tab>") 'hs-toggle-hiding)
                       (local-set-key (kbd "<backtab>") 'hs/hide-show-all)
                       (hs-minor-mode t)))
(defun hs/hide-show-all ()
  "Hide or show the contents of all headers."
  (interactive)
  (if (null (eq last-command 'hs/hide-show-all))
      (hs-hide-all)
    (hs-show-all)
    (setq this-command nil)))
#+END_SRC

** Markdown mode
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t)
#+END_SRC

** zeal-at-point
#+BEGIN_SRC emacs-lisp
(use-package zeal-at-point
  :ensure t
  :config
  (global-set-key "\C-cd" 'zeal-at-point)
  )
#+END_SRC

* End
#+BEGIN_SRC emacs-lisp
)
#+END_SRC

End.
