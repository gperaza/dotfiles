#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el
* Setup
** Personal information
Personal information is stored in personal.el.
This file must include personal information given as
> (setq user-full-name "MY NAME"
>       user-mail-address "MY EMAIL")
#+BEGIN_SRC emacs-lisp
(load "~/.dotfiles/personal.el")
#+END_SRC

** Setting up package manager and use-package
#+begin_src emacs-lisp
;; Please don't load outdated byte code
(setq load-prefer-newer t)

(require 'package)
(setq package-enable-at-startup nil)

(setq package-archives
      '(("elpy" . "http://jorgenschaefer.github.io/packages/")
        ("org"         . "http://orgmode.org/elpa/")
        ("gnu"         . "http://elpa.gnu.org/packages/")
        ("melpa-stable" . "http://melpa-stable.milkbox.net/packages/")
        ("melpa" . "http://melpa.org/packages/" )
        ))

(package-initialize)

;; Bootstrap `use-package'
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
;; (require 'diminish)
(require 'bind-key)

(use-package paradox
  :ensure t)
#+end_src

** Garbage collector and large file warning.
#+BEGIN_SRC emacs-lisp
;; reduce the frequency of garbage collection by making it happen on
;; each 50MB of allocated data (the default is on every 0.76MB)
(setq gc-cons-threshold 50000000)

;; warn when opening files bigger than 100MB
(setq large-file-warning-threshold 100000000)
#+END_SRC

** Backups
Send all backups to /tmp/
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+END_SRC

** Custom set variables
#+BEGIN_SRC emacs-lisp
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(custom-safe-themes
   (quote
    ("3c83b3676d796422704082049fc38b6966bcad960f896669dfc21a7a37a748fa" default)))
 '(paradox-github-token t)
 '(safe-local-variable-values
   (quote
    ((eval setq system-time-locale "es")
     (eval setq system-time-locale "C")
     (eval setq org-link-file-path-type 'relative)))))
#+END_SRC

* User interface
** Font settings
#+BEGIN_SRC emacs-lisp
(defvar ha/fixed-font-family "Source Code Pro")

(set-frame-font ha/fixed-font-family)
(set-face-attribute 'default nil :font ha/fixed-font-family)
(set-face-font 'default ha/fixed-font-family)

(if (< (x-display-pixel-width) 1920)
    (set-face-attribute 'default nil :height 100)
  (set-face-attribute 'default nil :height 120))
#+END_SRC

** Color theme
#+BEGIN_SRC emacs-lisp
(use-package monokai-theme
  :ensure t
  :config
  (load-theme 'monokai t))

(custom-set-faces
 '(org-block-begin-line
   ((t (:foreground "#E6DB74" :slant normal))))
 '(font-lock-comment-face
   ((t (:foreground "#E6DB74"))))
 '(font-lock-comment-delimiter-face
   ((t (:foreground "#E6DB74"))))
 '(font-lock-string-face
   ((t (:foreground "#e6a274"))))
 ;; '(org-block-end-line
 ;;   ((t (:underline "#008ED1" :foreground "#008ED1"))))
 '(writegood-weasels-face ((t (:underline (:color "gold" :style wave))))))
 #+END_SRC

** Smart mode line
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :ensure t
  :config (sml/setup)
  (setq sml/name-width 30))
#+END_SRC

** Start always maximized
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

** Set scratch message
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message nil)
#+END_SRC

** Menus and bars.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

** Disable blinking cursor and start up screen
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode -1)
(setq inhibit-startup-screen t)
#+END_SRC

** Nice scrolling, not centering after scrolling.
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 0
      scroll-conservatively 10000
      scroll-preserve-screen-position 1)

(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq auto-window-vscroll nil)

(setq org-file-apps
      '((auto-mode . emacs)
        ("\\.mm\\'" . default)
        ("\\.x?html?\\'" . "google-chorme %s")
        ("\\.pdf\\'" . default)
        ("\\.png\\'" . "pqiv -i %s")
        ("\\.jpg\\'" . "pqiv -i %s")
        ("\\.svg\\'" . "feh --magick-timeout 1 -. %s")))
#+END_SRC

** Display column number.
#+BEGIN_SRC emacs-lisp
(column-number-mode t)
#+END_SRC

** Enable y/n answers
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Better frame title
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '("" invocation-name " " (:eval (if (buffer-file-name)
                                          (abbreviate-file-name (buffer-file-name))
                                        "%b"))))
#+END_SRC

** Show unfinished keystroke early
#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.1)
#+END_SRC

** Olivetti mode
#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :ensure t
  :config
  (olivetti-set-width 85)
  (global-set-key (kbd "s-o") 'olivetti-mode)
  (define-key olivetti-mode-map (kbd "C-c [") nil)
  (define-key olivetti-mode-map (kbd "C-c ]") nil))
#+END_SRC

** Anzu, displays isearch information and query replace.
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :ensure t
  :config (global-anzu-mode)
  (global-set-key (kbd "M-%") 'anzu-query-replace)
  (global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp))
#+END_SRC

** Rich-minority
#+BEGIN_SRC emacs-lisp
(setq rm-whitelist "Projectile")
#+END_SRC

* Function definitions
#+BEGIN_SRC emacs-lisp
(use-package dash
  :ensure t)
(use-package ov
  :ensure t)
#+END_SRC

** Crux - replaces prelude functions
Here I bind the functions I find useful, there are more. See:
https://github.com/bbatsov/crux
#+BEGIN_SRC emacs-lisp
(use-package crux
  :ensure t
  :config
  (setq crux-indent-sensitive-modes
        '(conf-mode coffee-mode haml-mode
                    python-mode slim-mode yaml-mode org-mode))
  (global-set-key (kbd "C-c o") 'crux-open-with)
  (global-set-key [(control shift return)] 'crux-smart-open-line-above)
  (global-set-key [(shift return)] 'crux-smart-open-line)
  (global-set-key (kbd "C-c D") 'crux-delete-file-and-buffer)
  (global-set-key (kbd "C-c r") 'crux-rename-file-and-buffer)
  (global-set-key (kbd "C-c k") 'crux-kill-other-buffers)
  (global-set-key (kbd "C-c n") 'crux-cleanup-buffer-or-region)
  (global-set-key [remap move-beginning-of-line] #'crux-move-beginning-of-line)
  (global-set-key (kbd "s-k") 'crux-kill-line-backwards)
  (global-set-key (kbd "C-M-z") 'crux-indent-defun)
  (global-set-key (kbd "C-`") 'crux-switch-to-previous-buffer)

  (remove-hook 'find-file-hook #'crux-reopen-as-root))
#+END_SRC

** Function: switch-to-scratch-and-back
#+BEGIN_SRC emacs-lisp
(defun switch-to-scratch-and-back (arg)
  "Toggle between *scratch-MODE* buffer and the current buffer.
If a scratch buffer does not exist, create it with the major mode set to that
of the buffer from where this function is called.

        COMMAND -> Open/switch to a scratch buffer in the current buffer's major mode
    C-0 COMMAND -> Open/switch to a scratch buffer in `fundamental-mode'
    C-u COMMAND -> Open/switch to a scratch buffer in `org-mode'
C-u C-u COMMAND -> Open/switch to a scratch buffer in `emacs-elisp-mode'"
  (interactive "p")
  (if (and (= arg 1) ; no prefix
           (string-match-p "\\*scratch" (buffer-name)))
      (switch-to-buffer (other-buffer))
    (let ((mode-str (cl-case arg
                      (0  "fundamental-mode") ; C-0
                      (4  "org-mode") ; C-u
                      (16 "emacs-lisp-mode") ; C-u C-u
                      (t  (format "%s" major-mode))))) ; no prefix
      (switch-to-buffer (get-buffer-create
                         (concat "*scratch-" mode-str "*")))
      (funcall (intern mode-str)))))
#+END_SRC

** Function: get-path
#+BEGIN_SRC emacs-lisp
(defun get-path()
  "Opens dired so you can navigate to a file to insert a path to it in the current buffer."
  (interactive)
                                        ; store current point so we can change back to it later
  (setq current_point (point-marker))
                                        ; now call dired to navigate to the path you want
  (dired nil))
#+END_SRC

** Function: insert-relative-path
#+BEGIN_SRC emacs-lisp
(defun insert-relative-path()
  "Inserts the relative path between the original buffer and current file selected in dired."
  (interactive)
  (let ((selected_file (dired-get-filename)))
    (switch-to-buffer (marker-buffer current_point))
    (goto-char current_point)
    (insert (file-relative-name selected_file))))
#+END_SRC

** Function: insert-absolute-path
#+BEGIN_SRC emacs-lisp
(defun insert-absolute-path()
  "Inserts the absolute path to the file selected in dired to the previous buffer."
  (interactive)
  (let ((selected_file (dired-get-filename))) ; this is the file the cursor is on
    (switch-to-buffer (marker-buffer current_point))
    (goto-char current_point)
    (insert  (expand-file-name selected_file))))
#+END_SRC

** Function: unfill-paragraph
#+BEGIN_SRC emacs-lisp
(defun unfill-paragraph ()
  "Unfill paragraph at or after point."
  (interactive "*")
  (let ((fill-column most-positive-fixnum))
    (fill-paragraph nil (region-active-p))))
#+END_SRC

* Utilities
** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t
  :config (setq hydra-is-helpful t))
#+END_SRC

** Helm
Helm basic configuration following the official guide at
http://tuhdo.github.io/helm-intro.html.
#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :config
  (require 'helm-config)
  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

  (define-key helm-command-map (kbd "o")     'helm-occur)
  (define-key helm-command-map (kbd "SPC")   'helm-all-mark-rings)

  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "C-x C-b") 'helm-buffers-list)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "C-c f")  'helm-recentf)

  (setq helm-google-suggest-use-curl-p t)

  (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
        helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
        helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
        helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
        helm-ff-file-name-history-use-recentf t
        helm-M-x-fuzzy-match                  t
        helm-buffers-fuzzy-matching           t
        helm-recentf-fuzzy-match              t)

  (helm-mode 1))
#+END_SRC

** Key-chord
#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :ensure t
  :config (key-chord-mode +1))
#+END_SRC

** Magit (C-x g)
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :config
  (global-set-key (kbd "C-x g") 'magit-status)
  (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC

** Undo tree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :config
  (global-undo-tree-mode)
  (global-set-key (kbd "C-z") 'undo)
  (global-set-key (kbd "C-S-z") 'undo-tree-redo))
#+END_SRC

** Dired+
#+BEGIN_SRC emacs-lisp
(use-package dired+
  :ensure t)

;; show details by default
(setq diredp-hide-details-initially-flag nil)

;; set dired listing options
(setq dired-listing-switches "-alDhp")

;; reuse buffer
(diredp-toggle-find-file-reuse-dir 1)

;; make sure dired buffers end in a slash so we can identify them easily
(defun ensure-buffer-name-ends-in-slash ()
  "change buffer name to end with slash"
  (let ((name (buffer-name)))
    (if (not (string-match "/$" name))
        (rename-buffer (concat name "/") t))))
(add-hook 'dired-mode-hook 'ensure-buffer-name-ends-in-slash)
(add-hook 'dired-mode-hook
          (lambda()
            (setq truncate-lines 1)))

;; open files in external programs
;; from http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html
(defun xah-open-in-external-app (&optional file)
  "Open the current file or dired marked files in external app.
The app is chosen from your OS's preference."
  (interactive)
  (let (doIt
        (myFileList
         (cond
          ((string-equal major-mode "dired-mode")
           (dired-get-marked-files))
          ((not file) (list (buffer-file-name)))
          (file (list file)))))
    (setq doIt (if (<= (length myFileList) 5)
                   t
                 (y-or-n-p "Open more than 5 files? ")))
    (when doIt
      (cond
       ((string-equal system-type "windows-nt")
        (mapc
         (lambda (fPath)
           (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)))
         myFileList))
       ((string-equal system-type "darwin")
        (mapc
         (lambda (fPath)
           (shell-command (format "open \"%s\"" fPath)))
         myFileList))
       ((string-equal system-type "gnu/linux")
        (mapc
         (lambda (fPath)
           (let ((process-connection-type nil))
             (start-process "" nil "xdg-open" fPath))) myFileList))))))
;; open files from dired with "E"
(define-key dired-mode-map (kbd "E") 'xah-open-in-external-app)
#+END_SRC

** pdf-tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :config (pdf-tools-install)
  (add-hook 'pdf-view-mode-hook 'pdf-view-auto-slice-minor-mode))
#+END_SRC

** Eyebrowse
A window configuration manager. We bind it to M-W instead of C-c C-w
to avoid conflicts with org.
TODO define a hydra to use eyebrowse.
#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :ensure t
  :demand
  :init
  (setq eyebrowse-keymap-prefix (kbd "M-W"))
  (defhydra hydra-eyebrowse ()
    "eyebrowse"
    ("s" eyebrowse-switch-to-window-config "switch")
    ("n" eyebrowse-next-window-config "next")
    ("p" eyebrowse-prev-window-config "prev")
    ("l" eyebrowse-last-window-config "last")
    ("c" eyebrowse-close-window-config "close")
    ("r" eyebrowse-rename-window-config "rename")
    ("1" eyebrowse-switch-to-window-config-1)
    ("2" eyebrowse-switch-to-window-config-2)
    ("3" eyebrowse-switch-to-window-config-3)
    ("4" eyebrowse-switch-to-window-config-4)
    ("5" eyebrowse-switch-to-window-config-5)
    ("6" eyebrowse-switch-to-window-config-6)
    ("7" eyebrowse-switch-to-window-config-7)
    ("8" eyebrowse-switch-to-window-config-8)
    ("9" eyebrowse-switch-to-window-config-9)
    ("0" eyebrowse-switch-to-window-config-0)
    ("q" nil "quit"))
  :config
  (eyebrowse-mode t)
  (setq eyebrowse-new-workspace t)
  (global-set-key (kbd "M-1") 'hydra-eyebrowse/body)
)
#+END_SRC

** Tramp for ssh
Just open a file as usual with C-x C-f and then give the name of the
remote file, including the host
address. /user@host.server.com:/home/bjm/myfile.org
#+BEGIN_SRC emacs-lisp
(use-package tramp
  :config (setq tramp-default-method "ssh"))
#+END_SRC

** Flyspell and helm-flyspell
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :config
  (setq ispell-program-name "aspell" ; use aspell instead of ispell
        ispell-extra-args '("--sug-mode=ultra"))
  (add-hook 'text-mode-hook 'turn-on-flyspell)
  (add-hook 'prog-mode-hook 'flyspell-prog-mode))

;; ispell should not check code blocks in org mode
(add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
(add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "#\\+end_src"))
(add-to-list 'ispell-skip-region-alist '("^#\\+begin_example " . "#\\+end_example$"))
(add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_EXAMPLE " . "#\\+END_EXAMPLE$"))

(use-package helm-flyspell
  :ensure t
  :config (define-key flyspell-mode-map (kbd "C-;") 'helm-flyspell-correct))
#+END_SRC

** Company
We use company since it is included in Elpy already.
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (global-set-key (kbd "s-º") 'company-complete)
  (add-hook 'after-init-hook 'global-company-mode))

(use-package company-c-headers
  :ensure t
  :config
  (add-to-list 'company-backends 'company-c-headers))

(use-package company-auctex
  :ensure t)

(use-package company-math
  :ensure t
  :config
  (add-to-list 'company-backends 'company-math-symbols-unicode))

(defun my-company-latex-mode-setup ()
  (setq-local company-backends
              (append '(company-auctex-labels
                        company-auctex-bibs
                        (company-math-symbols-latex
                         company-auctex-macros
                         company-auctex-environments)
                        )
                      company-backends)))
(add-hook 'LaTeX-mode-hook 'my-company-latex-mode-setup)

;; Company for org-mode. Org-mode uses pcomplete for it's own
;; completion. We add it to the capf backend.
(defun add-pcomplete-to-capf ()
  (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))

(add-hook 'org-mode-hook #'add-pcomplete-to-capf)
#+END_SRC

** Words hydra
Function to operate on words at point or region, from
https://github.com/jkitchin/jmax/blob/master/words.el

*** Functions
#+BEGIN_SRC emacs-lisp
(defun words-dictionary ()
  "Look up word at point in an online dictionary."
  (interactive)
  (browse-url
   (format
    "http://dictionary.reference.com/browse/%s?s=t"
    (thing-at-point 'word))))


(defun words-thesaurus ()
  "Look up word at point in an online thesaurus."
  (interactive)
  (browse-url
   (format
    "http://www.thesaurus.com/browse/%s"
    (thing-at-point 'word))))

(defun words-atd ()
  "Send paragraph at point to After the deadline for spell and grammar checking."
  (interactive)

  (let* ((url-request-method "POST")
         (url-request-data (format
                            "key=some-random-text-&data=%s"
                            (url-hexify-string
                             (thing-at-point 'paragraph))))
         (xml  (with-current-buffer
                   (url-retrieve-synchronously
                    "http://service.afterthedeadline.com/checkDocument")
                 (xml-parse-region url-http-end-of-headers (point-max))))
         (results (car xml))
         (errors (xml-get-children results 'error)))

    (switch-to-buffer-other-frame "*ATD*")
    (erase-buffer)
    (dolist (err errors)
      (let* ((children (xml-node-children err))
             ;; for some reason I could not get the string out, and had to do this.
             (s (car (last (nth 1 children))))
             ;; the last/car stuff doesn't seem right. there is probably
             ;; a more idiomatic way to get this
             (desc (last (car (xml-get-children children 'description))))
             (type (last (car (xml-get-children children 'type))))
             (suggestions (xml-get-children children 'suggestions))
             (options (xml-get-children (xml-node-name suggestions) 'option))
             (opt-string  (mapconcat
                           (lambda (el)
                             (when (listp el)
                               (car (last el))))
                           options
                           " ")))

        (insert (format "** %s ** %s
      Description: %s
      Suggestions: %s
      " s type desc opt-string))))))

(defun words-google ()
  "Google the word at point or selection."
  (interactive)
  (browse-url
   (format
    "http://www.google.com/search?q=%s"
    (if (region-active-p)
        (url-hexify-string (buffer-substring (region-beginning)
                                             (region-end)))
      (thing-at-point 'word)))))

(defun words-google-scholar ()
  "Google scholar the word at point or selection."
  (interactive)
  (browse-url
   (format
    "http://scholar.google.com/scholar?q=%s"
    (if (region-active-p)
        (url-hexify-string (buffer-substring (region-beginning)
                                             (region-end)))
      (thing-at-point 'word)))))

#+END_SRC

*** Hydra
#+BEGIN_SRC emacs-lisp
 (defhydra hydra-words (:color blue)
   "words"
   ("d" words-dictionary "dictionary")
   ("t" words-thesaurus "thesaurus")
   ("s" words-atd "spell/grammar")
   ("g" words-google "google")
   ("G" words-google-scholar "google scholar")
   ("q" nil "cancel"))
(global-set-key (kbd "s-d") 'hydra-words/body)
#+END_SRC

* Editing configuration
** Zop-to-char (kills from current point to character, M-z/M-Z)
#+BEGIN_SRC emacs-lisp
(use-package zop-to-char
  :ensure t
  :config
  (global-set-key (kbd "M-z") 'zop-up-to-char)
  (global-set-key (kbd "M-Z") 'zop-to-char))
#+END_SRC

** Move lines or region up and down
To imitate move lines outside org mode.
#+BEGIN_SRC emacs-lisp
(use-package move-text
  :ensure t
  :config
  (global-set-key (kbd "M-S-<up>")  'move-text-up)
  (global-set-key (kbd "M-S-<down>") 'move-text-down))
#+END_SRC

** Eliminate tabs but maintain tab length
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)   ;; don't use tabs to indent
(setq-default tab-width 8)            ;; but maintain correct appearance
#+END_SRC

** Require new line at the end of a file
#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

** Delete selection when copying/writing on top
#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

** Auto revert files
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC

** Hippie-expand
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-/") 'hippie-expand)
(setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                         try-expand-dabbrev-all-buffers
                                         try-expand-dabbrev-from-kill
                                         try-complete-file-name-partially
                                         try-complete-file-name
                                         try-expand-all-abbrevs
                                         try-expand-list
                                         try-expand-line
                                         try-complete-lisp-symbol-partially
                                         try-complete-lisp-symbol))
#+END_SRC

** Set tab behavior, indent or complete
Set t for only indent, set 'complete to indent or complete at point.
#+BEGIN_SRC emacs-lisp
;; smart tab behavior - indent or complete
(setq tab-always-indent t)
#+END_SRC

** Parenthesis
#+BEGIN_SRC emacs-lisp
(use-package smartparens-config
  :ensure smartparens
  :config
  (show-smartparens-global-mode t)
  (smartparens-global-mode 1)
  (define-key prog-mode-map (kbd "M-q") 'sp-indent-defun))
#+END_SRC

** Remember location in a file when saving
#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :ensure t
  :config
  (setq save-place-file (expand-file-name "saveplace" "~/.emacs.d/savefile/"))
  ;; activate it for all buffers
  (setq-default save-place t))
#+END_SRC

** Save recent files
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :config
  (setq recentf-save-file (expand-file-name "recentf" "~/.emacs.d/savefile/")
        recentf-max-saved-items 10
        recentf-max-menu-items 10
        ;; disable recentf-cleanup on Emacs start, because it can cause
        ;; problems with remote files
        recentf-auto-cleanup 'never)

  (defun prelude-recentf-exclude-p (file)
    "A predicate to decide whether to exclude FILE from recentf."
    (let ((file-dir (file-truename (file-name-directory file))))
      (-any-p (lambda (dir)
                (string-prefix-p dir file-dir))
              (mapcar 'file-truename (list "~/.emacs.d/savefile/" "~/.emacs.d/elpa/")))))

  (add-to-list 'recentf-exclude 'prelude-recentf-exclude-p)
  ;; ignore magit's commit message files
  (add-to-list 'recentf-exclude "COMMIT_EDITMSG\\'")

  (recentf-mode +1))
#+END_SRC

** Volatile highlights, highlight things like undo, copy, etc.
#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :ensure t
  :config (volatile-highlights-mode t))
#+END_SRC

** Make kill-region (C-w) kill single line when not selection is active
#+BEGIN_SRC emacs-lisp
;; note - this should be after volatile-highlights is required
;; add the ability to cut the current line, without marking it
(defadvice kill-region (before smart-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+END_SRC

** Set up easy-kill, smart M-w replacement
#+BEGIN_SRC emacs-lisp
(use-package easy-kill
  :ensure t
  :config
  (global-set-key [remap kill-ring-save] 'easy-kill)
  (global-set-key [remap mark-sexp] 'easy-mark))
#+END_SRC

** White space mode
#+BEGIN_SRC emacs-lisp
(setq whitespace-line-column 80)
(setq whitespace-style '(face tabs empty trailing lines-tail))
(add-hook 'prog-mode-hook 'whitespace-mode)
(add-hook 'LaTeX-mode-hook 'whitespace-mode)
#+END_SRC

** Enable narrowing commands
#+BEGIN_SRC emacs-lisp
;; C-x n w makes entire buffer accesible again
(put 'narrow-to-region 'disabled nil) ;;C-x n n
(put 'narrow-to-page 'disabled nil)   ;;C-x n p
(put 'narrow-to-defun 'disabled nil)  ;;C-x n d
#+END_SRC

** Enable erase-buffer command
#+BEGIN_SRC emacs-lisp
(put 'erase-buffer 'disabled nil)
#+END_SRC

** Expand region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :config (global-set-key (kbd "M-2") 'er/expand-region))
#+END_SRC

** Ediff, view file differences
#+BEGIN_SRC emacs-lisp
(use-package ediff
  :config (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+END_SRC

** Make untabify and indent-region work in the whole buffer
#+BEGIN_SRC emacs-lisp
(require 'tabify)
(crux-with-region-or-buffer indent-region)
(crux-with-region-or-buffer untabify)
#+END_SRC

** Automatically indent yanked text in programming modes
#+BEGIN_SRC emacs-lisp
(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) 1000)
      (indent-region beg end nil)))

(defcustom prelude-yank-indent-modes '(LaTeX-mode TeX-mode)
  "Modes in which to indent regions that are yanked (or yank-popped).
      Only modes that don't derive from `prog-mode' should be listed here."
  :type 'list
  :group 'prelude)

(defmacro advise-commands (advice-name commands class &rest body)
  "Apply advice named ADVICE-NAME to multiple COMMANDS.
      The body of the advice is in BODY."
  `(progn
     ,@(mapcar (lambda (command)
                 `(defadvice ,command (,class ,(intern (concat (symbol-name command) "-" advice-name)) activate)
                    ,@body))
               commands)))

(advise-commands "indent" (yank yank-pop) after
                 "If current mode is one of `prelude-yank-indent-modes',
      indent yanked text (with prefix arg don't indent)."
                 (if (and (not (ad-get-arg 0))
                          (not (member major-mode crux-indent-sensitive-modes))
                          (or (derived-mode-p 'prog-mode)
                              (member major-mode prelude-yank-indent-modes)))
                     (let ((transient-mark-mode nil))
                       (yank-advised-indent-function (region-beginning) (region-end)))))

#+END_SRC

** Make shell script executable automatically on save
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Saner regexp syntax
#+BEGIN_SRC emacs-lisp
(require 're-builder)
(setq reb-re-syntax 'string)
#+END_SRC

** Compilation
Let's customize the behavior of the compilation process. We always to
save when compiling, no need to ask. Also, if a previous compilation
process exists, kill it before starting a new one. Finally,
automatically scroll to first error.

We can interpret the ansi color escape codes to colorize the
compilation buffer. For this we follow Malabarba's [[http://endlessparentheses.com/ansi-colors-in-the-compilation-buffer-output.html?source=rss][advice]].
#+BEGIN_SRC emacs-lisp
(require 'compile)
(setq compilation-ask-about-save nil
      compilation-always-kill t
      compilation-scroll-output 'first-error)

(require 'ansi-color)
(defun endless/colorize-compilation ()
  "Colorize from `compilation-filter-start' to `point'."
  (let ((inhibit-read-only t))
    (ansi-color-apply-on-region
     compilation-filter-start (point))))

(add-hook 'compilation-filter-hook
          #'endless/colorize-compilation)
#+END_SRC

** Turn on auto-fill and visual-line-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)

(use-package adaptive-wrap
  :ensure t)

(defun my-activate-adaptive-wrap-prefix-mode ()
  "Toggle `visual-line-mode' and `adaptive-wrap-prefix-mode' simultaneously."
  (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))

(add-hook 'visual-line-mode-hook 'my-activate-adaptive-wrap-prefix-mode)
#+END_SRC

** Change case of letters
#+BEGIN_SRC emacs-lisp
(defun toggle-letter-case ()
  "Toggle the letter case of current word or text selection.
Toggles between: “all lower”, “Init Caps”, “ALL CAPS”."
  (interactive)
  (let (p1 p2 (deactivate-mark nil) (case-fold-search nil))
    (if (region-active-p)
        (setq p1 (region-beginning) p2 (region-end))
      (let ((bds (bounds-of-thing-at-point 'word) ) )
        (setq p1 (car bds) p2 (cdr bds)) ) )

    (when (not (eq last-command this-command))
      (save-excursion
        (goto-char p1)
        (cond
         ((looking-at "[[:lower:]][[:lower:]]") (put this-command 'state "all lower"))
         ((looking-at "[[:upper:]][[:upper:]]") (put this-command 'state "all caps") )
         ((looking-at "[[:upper:]][[:lower:]]") (put this-command 'state "init caps") )
         ((looking-at "[[:lower:]]") (put this-command 'state "all lower"))
         ((looking-at "[[:upper:]]") (put this-command 'state "all caps") )
         (t (put this-command 'state "all lower") ) ) )
      )

    (cond
     ((string= "all lower" (get this-command 'state))
      (upcase-initials-region p1 p2) (put this-command 'state "init caps"))
     ((string= "init caps" (get this-command 'state))
      (upcase-region p1 p2) (put this-command 'state "all caps"))
     ((string= "all caps" (get this-command 'state))
      (downcase-region p1 p2) (put this-command 'state "all lower")) )
    )
  )

;;set this to M-c
(global-set-key "\M-c" 'toggle-letter-case)
#+END_SRC

** TeX input method
Allows typing TeX characters after toggling the input method with C-\
#+BEGIN_SRC emacs-lisp
(setq default-input-method 'TeX)
#+END_SRC

** Subword mode
Treats camel case words (camelCase) as separate words.
#+BEGIN_SRC emacs-lisp
(global-subword-mode 1)
#+END_SRC

** A transpose hydra
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-t")
    (defhydra hydra-transpose (:color red)
    "Transpose"
     ("c" transpose-chars "characters")
     ("w" transpose-words "words")
     ("o" org-transpose-words "Org mode words")
     ("l" transpose-lines "lines")
     ("s" transpose-sentences "sentences")
     ("e" org-transpose-elements "Org mode elements")
     ("p" transpose-paragraphs "paragraphs")
     ("t" org-table-transpose-table-at-point "Org mode table")
     ("q" nil "cancel" :color blue)))
#+END_SRC

* Navigation
** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :config
  (setq avy-background t)
  (setq avy-style 'at-full)
  (key-chord-define-global "jj" 'avy-goto-word-or-subword-1)
  (key-chord-define-global "jl" 'avy-goto-line)
  (key-chord-define-global "jk" 'avy-goto-char))
#+END_SRC

** Ace-window
Can swap and delete windows as well.
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :config
  (global-set-key (kbd "C-x o") 'ace-window)
  (global-set-key (kbd "C-c s") 'ace-swap-window))
#+END_SRC

** Windmove to move between visible buffers
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :bind
  (("s-<right>" . windmove-right)
   ("s-<left>" . windmove-left)
   ("s-<up>" . windmove-up)
   ("s-<down>" . windmove-down)
   ))
#+END_SRC

** Winner mode, undo-redo window configuration
#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure t
  :config (winner-mode 1))
#+END_SRC

** Helm-swoop
#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :ensure t)

(global-set-key (kbd "C-s") 'helm-swoop)
(global-set-key (kbd "C-r") 'helm-swoop-back-to-last-point)
(global-set-key (kbd "C-M-s") 'helm-multi-swoop)

;; From helm-swoop to other
(define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
(define-key helm-swoop-map (kbd "M-c") 'helm-multi-swoop-current-mode-from-helm-swoop)

;; Move up and down like isearch
(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
(define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
(define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

;; Save buffer when helm-multi-swoop-edit complete
(setq helm-multi-swoop-edit-save t)

;; If this value is t, split window inside the current window
(setq helm-swoop-split-with-multiple-windows nil)

;; Split direcion. 'split-window-vertically or 'split-window-horizontally
(setq helm-swoop-split-direction 'split-window-vertically)

;; If nil, you can slightly boost invoke speed in exchange for text color
(setq helm-swoop-speed-or-color t)

;; ;; Go to the opposite side of line from the end or beginning of line
(setq helm-swoop-move-to-line-cycle t)

;; Optional face for line numbers
;; Face name is `helm-swoop-line-number-face`
(setq helm-swoop-use-line-number-face t)

;; Match/Search methods (Fuzzy matching, Migemo)
;; If you do not preferr fuzzy, remove it from the list below
(defvar helm-c-source-swoop-match-functions
  '(helm-mm-exact-match
    helm-mm-match
    ;;    helm-fuzzy-match
    ;;    helm-mm-3-migemo-match
    ))
(setq helm-c-source-swoop-search-functions
      '(helm-mm-exact-search
        helm-mm-search
        helm-candidates-in-buffer-search-default-fn
        ;;        helm-fuzzy-search
        ;;        helm-mm-3-migemo-search
        ))

;; disable pre-input
(setq helm-swoop-pre-input-function
      (lambda () ""))
#+END_SRC

** Helm-mt and multi-term
#+BEGIN_SRC emacs-lisp
(use-package helm-mt
  :ensure t
  :config
  (global-set-key (kbd "C-c t") 'helm-mt)
  (add-hook 'term-mode-hook
          (lambda ()
            (toggle-truncate-lines)
            ;(setq term-prompt-regexp "^.*❯❯❯ ")
            ;(make-local-variable 'mouse-yank-at-point)
            ;(setq mouse-yank-at-point t)
            ;(make-local-variable 'transient-mark-mode)
            ;(setq transient-mark-mode nil)
            ;(setq yas-dont-activate t)
             )))
#+END_SRC

** Helm-semantic-or-imenu and imenu-anywhere
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c i") 'helm-semantic-or-imenu)
(use-package imenu-anywhere
  :ensure t
  :config (global-set-key (kbd "C-c I") 'helm-imenu-anywhere))
#+END_SRC

** Back button
Navigate the mark ring, replaces binding for next/previous-buffer
which I rarely use.
#+BEGIN_SRC emacs-lisp
(use-package back-button
  :ensure t
  :config (back-button-mode 1))
#+END_SRC

** Meaningful names for buffers with the same name
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-after-kill-buffer-p t)    ; rename after killing uniquified
  (setq uniquify-ignore-buffers-re "^\\*")) ; don't muck with special buffers
#+END_SRC

* LaTeX
The latex-extra package provides foldind, novigation, 1-key
compilation and white space handling.
#+BEGIN_SRC emacs-lisp
(use-package tex
  :ensure auctex)
(use-package cdlatex
  :ensure t)

(setq-default TeX-master nil)
(setq TeX-auto-save t)
(setq TeX-parse-self t)

;; Use pdf-tools to open PDF files
(setq TeX-view-program-selection '((output-pdf "PDF Tools"))
      TeX-source-correlate-start-server t)
;; Update PDF buffers after successful LaTeX runs and trim margins
(add-hook 'TeX-after-compilation-finished-functions
           'TeX-revert-document-buffer)

(add-hook 'LaTeX-mode-hook
          (lambda ()
            (flyspell-mode t)
            (TeX-PDF-mode t)
            (TeX-fold-mode t)
            (turn-on-reftex)
            (turn-on-cdlatex)
            (TeX-source-correlate-mode t)
            (imenu-add-to-menubar "Index")
            ;; Allow paragraph filling in tables
            (setq LaTeX-indent-environment-list
                  (delq (assoc "table" LaTeX-indent-environment-list)
                        LaTeX-indent-environment-list))
            (setq LaTeX-indent-environment-list
                  (delq (assoc "table*" LaTeX-indent-environment-list)
                        LaTeX-indent-environment-list))))

;; reftex settings
(setq reftex-enable-partial-scans t)
(setq reftex-use-multiple-selection-buffers t)
(setq reftex-plug-into-AUCTeX t)



;; Provides foldind, novigation, 1-key compilation and whitespace handling.
(use-package latex-extra
  :ensure t
  :config
  (add-hook 'LaTeX-mode-hook #'latex-extra-mode))

(defface endless/unimportant-latex-face
  '((t :height 0.7
       :inherit font-lock-comment-face))
  "Face used on less relevant math commands.")

(font-lock-add-keywords
 'latex-mode
 `((,(rx (or (and "\\" (or (any ",.!;")
                           (and (or "left" "right"
                                    "big" "Big")
                                symbol-end)))
             (any "_^")))
    0 'endless/unimportant-latex-face prepend))
 'end)

;; This is a jack to preview fragments in org mode
(define-key LaTeX-mode-map (kbd "C-c C-x C-l") 'org-preview-latex-fragment)
#+END_SRC

* org-mode
Org-mode it's the main reason I use Emacs. Here we configure it to our
liking. First we load the latest org and extras goodies from org-contrib.

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure org-plus-contrib)
#+END_SRC

** Appearance
Here we make org buffers look nice. Only affects visuals.

Change the ellipsis at the end of collapsed nodes and replace the
asterisks at the beginning of headings with nicer symbols:

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " ▼")
(require 'org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

This hides the markup markers (* for bold. / for emphasis, etc.), they
are still there, just hidden:

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

We change the "-" in lists to nice bullets:

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 '(("^ +\\([-*]\\) "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC

I like to keep text width under 80 characters. Indentation in lower
level headings makes things look weird so we disable indentation all
together.

#+BEGIN_SRC emacs-lisp
(setq org-adapt-indentation nil)
#+END_SRC

Set tag alignment to look good with the 80 character limit and big
headers:

#+BEGIN_SRC emacs-lisp
(setq org-tags-column -60)
#+END_SRC

Make code blocks pretty:

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

Increase the size of and colorize latex fragments in text:

#+BEGIN_SRC emacs-lisp
(plist-put org-format-latex-options :scale 1.5)

(eval-after-load 'org
  '(setf org-highlight-latex-and-related '(latex)))
#+END_SRC

** Babel, code inside org
Babel is Org-mode's ability to execute source code within Org-mode
documents.

*** Enable languages
First we need to tell babel which languages we intend to use, we can
add more later.

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (sh . t)
   (org . t)
   (C . t)
   (latex . t)
   (awk . t)
   (gnuplot . t)))
#+END_SRC

We also include support for ipython blocks via the [[https://github.com/gregsexton/ob-ipython][ob-ipython]] package.

#+BEGIN_SRC emacs-lisp
(use-package ob-ipython
  :ensure t)
#+END_SRC

*** Set up Babel behavior
In frames with multiple windows is better to edit code in the same
window:

#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window)
#+END_SRC

Don't ask for confirmation when evaluating a code block.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil
      org-confirm-elisp-link-function nil
      org-confirm-shell-link-function nil)
#+END_SRC

I generally have huge and slow code blocks, we don't want to evaluate
this on export. Also, being huge better keep them folded at startup.

#+BEGIN_SRC emacs-lisp
(setq org-export-babel-evaluate nil)
(setq org-hide-block-startup t)
#+END_SRC

Code block indentation messes up indent sensitive languages like
Python, disable it. While we are messing with indentation let's make
tab behave as in the native major mode inside blocks.

#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)
(setq org-src-tab-acts-natively t)
#+END_SRC

When evaluating blocks I want them be silent, usually I only use them
to process data. Also export both code and results.

#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args
      (cons '(:results . "silent")
            (assq-delete-all :results org-babel-default-header-args)))

(setq org-babel-default-header-args
      (cons '(:exports . "both")
            (assq-delete-all :exports org-babel-default-header-args)))
#+END_SRC

*** Killing and restarting sessions
Here I define a pair of functions to restart and kill sessions.
Restarting a session means kill it, the run all the blocks belonging
to the session up to the current block. This functions were created by
John Kitchin.

#+BEGIN_SRC emacs-lisp
(defun src-block-in-session-p (&optional name)
  "Return if src-block is in a session of NAME.
NAME may be nil for unnamed sessions."
  (let* ((info (org-babel-get-src-block-info))
         (lang (nth 0 info))
         (body (nth 1 info))
         (params (nth 2 info))
         (session (cdr (assoc :session params))))

    (cond
     ;; unnamed session, both name and session are nil
     ((and (null session)
           (null name))
      t)
     ;; Matching name and session
     ((and
       (stringp name)
       (stringp session)
       (string= name session))
      t)
     ;; no match
     (t nil))))

(defun org-babel-restart-session-to-point (&optional arg)
  "Restart session up to the src-block in the current point.
Goes to beginning of buffer and executes each code block with
`org-babel-execute-src-block' that has the same language and
session as the current block. ARG has same meaning as in
`org-babel-execute-src-block'."
  (interactive "P")
  (unless (org-in-src-block-p)
    (error "You must be in a src-block to run this command"))
  (org-babel-kill-session)
  (let* ((current-point (point-marker))
         (info (org-babel-get-src-block-info))
         (lang (nth 0 info))
         (params (nth 2 info))
         (session (cdr (assoc :session params))))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward org-babel-src-block-regexp nil t)
        ;; goto start of block
        (goto-char (match-beginning 0))
        (let* ((this-info (org-babel-get-src-block-info))
               (this-lang (nth 0 this-info))
               (this-params (nth 2 this-info))
               (this-session (cdr (assoc :session this-params))))
          (when
              (and
               (< (point) (marker-position current-point))
               (string= lang this-lang)
               (src-block-in-session-p session))
            (org-babel-execute-src-block arg)))
        ;; move forward so we can find the next block
        (forward-line)))))

(defun org-babel-kill-session ()
  "Kill session for current code block."
  (interactive)
  (unless (org-in-src-block-p)
    (error "You must be in a src-block to run this command"))
  (save-window-excursion
    (org-babel-switch-to-session)
    (kill-buffer)))
#+END_SRC

*** Wrap text in a code block
Sometimes I need to wrap some text inside a code block, specially for
LaTeX code. I don't remember where I find this but it is useful.

#+BEGIN_SRC emacs-lisp
(defun org-begin-template ()
  "Make a template at point."
  (interactive)
  (if (org-at-table-p)
      (call-interactively 'org-table-rotate-recalc-marks)
    (let* ((choices '(("s" . "SRC")
                      ("e" . "EXAMPLE")
                      ("q" . "QUOTE")
                      ("v" . "VERSE")
                      ("c" . "CENTER")
                      ("l" . "LaTeX")
                      ("h" . "HTML")
                      ("a" . "ASCII")))
           (key
            (key-description
             (vector
              (read-key
               (concat (propertize "Template type: " 'face 'minibuffer-prompt)
                       (mapconcat (lambda (choice)
                                    (concat (propertize (car choice) 'face 'font-lock-type-face)
                                            ": "
                                            (cdr choice)))
                                  choices
                                  ", ")))))))
      (let ((result (assoc key choices)))
        (when result
          (let ((choice (cdr result)))
            (cond
             ((region-active-p)
              (let ((start (region-beginning))
                    (end (region-end)))
                (goto-char end)
                (insert "#+END_" choice "\n")
                (goto-char start)
                (insert "#+BEGIN_" choice "\n")))
             (t
              (insert "#+BEGIN_" choice "\n")
              (save-excursion (insert "#+END_" choice))))))))))

;;bind to key
(define-key org-mode-map (kbd "C-<") 'org-begin-template)
#+END_SRC

** Editing
Configuration of some ways to write in org.

*** Footnotes
In-line and still reference-able footnote definitions. Footnotes have
random unique id's and being inline means it is difficult to mess up
references by deleting stuff.

#+BEGIN_SRC emacs-lisp
(setq org-footnote-define-inline t)
(setq org-footnote-auto-label 'random)
(setq org-footnote-auto-adjust nil)
#+END_SRC

*** Lists
Allow lists with letters in them.

#+BEGIN_SRC emacs-lisp
(setq org-list-allow-alphabetical t)
#+END_SRC

*** Org CDLatex
CDLaTeX allows to insert environments easily in org using "C-{".

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+END_SRC

** Org mode links
Enable storing, inserting and following links in any buffer:

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-cL" 'org-insert-link-global)
(global-set-key "\C-co" 'org-open-at-point-global)
#+END_SRC

*** Minor mode to font lock links outside org
Here we define a minor mode to font lock Org links in non org buffers.
Derived from [[https://github.com/seanohalpin/org-link-minor-mode][here]] but without the key bindings. I find it less
obtrusive to use the org included global functions.

#+BEGIN_SRC emacs-lisp
(defun org-link-minor-mode-unfontify-region (beg end &optional maybe_loudly)
  "Remove fontification and activation overlays from links."
  (font-lock-default-unfontify-region beg end)
  (let* ((buffer-undo-list t)
         (inhibit-read-only t) (inhibit-point-motion-hooks t)
         (inhibit-modification-hooks t)
         deactivate-mark buffer-file-name buffer-file-truename)
    (org-decompose-region beg end)
    (remove-text-properties beg end
                            '(mouse-face t keymap t org-linked-text t
                                         invisible t intangible t
                                         help-echo t rear-nonsticky t
                                         org-no-flyspell t org-emphasis t))
    (org-remove-font-lock-display-properties beg end)))

;;;###autoload
(define-minor-mode org-link-minor-mode
  "Toggle display of org-mode style bracket links in non-org-mode buffers."
  :lighter " org-link"

  (let ((org-link-minor-mode-keywords
         (list
          '(org-activate-angle-links (0 'org-link t))
          '(org-activate-plain-links)
          '(org-activate-bracket-links (0 'org-link t))
          '(org-activate-dates (0 'org-date t))
          ))
        )
    (if org-link-minor-mode
        (if (derived-mode-p 'org-mode)
            (progn
              (message "org-mode doesn't need org-link-minor-mode")
              (org-link-minor-mode -1)
              )
          (font-lock-add-keywords nil org-link-minor-mode-keywords t)
          (org-set-local 'org-descriptive-links org-descriptive-links)
          (if org-descriptive-links (add-to-invisibility-spec '(org-link)))
          (org-set-local 'font-lock-unfontify-region-function
                         'org-link-minor-mode-unfontify-region)
          (org-restart-font-lock)
          )
      (unless (derived-mode-p 'org-mode)
        (font-lock-remove-keywords nil org-link-minor-mode-keywords)
        (org-restart-font-lock)
        (remove-from-invisibility-spec '(org-link))
        (kill-local-variable 'org-descriptive-links)
        (kill-local-variable 'font-lock-unfontify-region-function)
        )
      )
    )
  )

(add-hook 'prog-mode-hook 'org-link-minor-mode)
(add-hook 'LaTeX-mode-hook 'org-link-minor-mode)
#+END_SRC

*** Custom link types
Define a link to a YouTube video as defined [[http://endlessparentheses.com/embedding-youtube-videos-with-org-mode-links.html][here]].

#+BEGIN_SRC emacs-lisp
(defvar yt-iframe-format
  ;; You may want to change your width and height.
  (concat "<iframe width=\"440\""
          " height=\"335\""
          " src=\"https://www.youtube.com/embed/%s\""
          " frameborder=\"0\""
          " allowfullscreen>%s</iframe>"))

(org-add-link-type
 "yt"
 (lambda (handle)
   (browse-url
    (concat "https://www.youtube.com/embed/"
            handle)))
 (lambda (path desc backend)
   (cl-case backend
     (html (format yt-iframe-format
                   path (or desc "")))
     (latex (format "\href{%s}{%s}"
                    path (or desc "video"))))))
#+END_SRC

** Navigation
Enable fast navigation on headers. To see a list of available commands
press ? with the cursor at the beginning of a headline.

#+BEGIN_SRC emacs-lisp
(setq org-use-speed-commands t)
#+END_SRC

A hydra to navigate when not in a heading. Useful when I don't
remember the commands. Now includes the useful ~org-toc-show~ to show a
table of contents.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org (:color red :columns 3)
  "Org Mode Movements"
  ("n" outline-next-visible-heading "next heading")
  ("p" outline-previous-visible-heading "prev heading")
  ("N" org-forward-heading-same-level "next heading at same level")
  ("P" org-backward-heading-same-level "prev heading at same level")
  ("u" outline-up-heading "up heading")
  ("g" org-goto "goto" :exit t)
  ("t" org-toc-show "TOC" :exit t))

(define-key org-mode-map (kbd "s-n") 'hydra-org/body)
#+END_SRC

Set some org-toc properties, activate follow mode:
#+BEGIN_SRC emacs-lisp
(setq org-toc-follow-mode t)
#+END_SRC

Replace imenu with the superior helm-org-in-buffer-headings to
navigate an org buffer.

#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "C-c i") 'helm-org-in-buffer-headings)
#+END_SRC

Function that replaces the entire key map for narrow widen in org.
Narrowing is really useful to focus only on the relevant section we
want to edit. Now we can narrow/widen smartly using only
C-x n. Works globally, not only in org-mode, perhaps I should move
this elsewhere.

#+BEGIN_SRC emacs-lisp
(defun narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or defun,
whichever applies first. Narrowing to org-src-block actually
calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer is
already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing
         ;; command. Remove this first conditional if you
         ;; don't want it.
         (cond ((ignore-errors (org-edit-src-code))
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        ((derived-mode-p 'latex-mode)
         (LaTeX-narrow-to-environment))
        (t (narrow-to-defun))))

;; This line actually replaces Emacs' entire narrowing
;; keymap, that's how much I like this command. Only copy it
;; if that's what you want.
(define-key ctl-x-map "n" #'narrow-or-widen-dwim)
(eval-after-load 'latex
  '(define-key LaTeX-mode-map "\C-xn" nil))
#+END_SRC

** Org capture
Org capture allows to quickly write to do's and notes without leaving
what we are currently doing. We start to capture with "C-c c".

#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-cc" 'org-capture)
#+END_SRC

For templates that do not define a target, I want notes stored in
Notes/inbox.org.

#+BEGIN_SRC emacs-lisp
(setq org-default-notes-file "~/Documents/Notes/inbox.org")
#+END_SRC

The default behavior is to add the note at a header specified by the
template. We can also choose a header by choosing "refiling" when
exiting org-capture. Here I allow for new headings to be created when
refiling. For some reason the org buffer is not saved when refiling,
so I advice org refile to save all buffers when done. This is an ugly
hack, there should be a better way of doing this.

#+BEGIN_SRC emacs-lisp
(setq org-refile-allow-creating-parent-nodes t)

;; Ugly hack to save the file after refiling.
(advice-add 'org-refile :after #'org-save-all-org-buffers)
#+END_SRC

*** Templates
One the best things about org-capture is that you can define your own
templates for capturing.

Here I define a template to store notes in files inside my Notes directory.
Using "s" prompts for the file to store the note, if the file does not
exists it creates it. I still need a template for a global to-do list.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(
        ("s" "Note (select file)" entry (file+headline
          (read-file-name "File to capture to:" "~/Documents/Notes/") "Refile")
         "** %?\n %i\n")
        ))
#+END_SRC

** Agenda setup
I don't use the agenda but it is my intention to learn how to.
Supposedly one of the strong points in org.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-ca" 'org-agenda)

(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-skip-timestamp-if-done t)
(setq org-agenda-todo-ignore-scheduled t)
(setq org-agenda-todo-ignore-deadlines t)
(setq org-agenda-todo-ignore-timestamp t)
(setq org-agenda-todo-ignore-with-date t)
(setq org-agenda-start-on-weekday nil) ;; start on current day

;; give me some warning of upcoming deadlines
(setq org-deadline-warning-days 0)

;; record time I finished a task when I change it to DONE
(setq org-log-done 'time)
#+END_SRC

** Org mode exporter
Org-mode allow us to export our document to different formats. The two
I use the most are LaTeX and HTML.

*** Export back-ends
Enable back-ends for export formats. Aside from LaTeX and HTML, beamer
is to make presentations, koma-letter is a LaTeX class for letters and
ox-bibtex handles citations in HTML exports, for LaTeX citations I use
[[*Org-ref][org-ref]].

#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(require 'ox-html)
(require 'ox-beamer)
(require 'ox-koma-letter)
(require 'ox-bibtex)
#+END_SRC

**** TODO Tufte-org-mode
An Org mode environment for producing Tufte-LaTeX books and handouts.

**** LaTeX back-end configuration
The LaTeX back-end needs some extra configuration.

Define extra packages to be included in latex exports.

#+BEGIN_SRC emacs-lisp
(setq org-latex-packages-alist
      '(("" "lmodern" nil);; latin modern fonts
        ("" "mathtools" t);; superseeds amsmath
        ("" "url" nil);; enable \url{} for urls
        ("" "color" nil)
        ("" "amssymb" nil)
        ("" "amsopn" nil)
        ("" "nicefrac" nil)
        ("" "units" nil)
        ("" "gensymb" nil)
        ))
#+END_SRC

To enable syntax highlighting for source code in LaTeX export we need
pygmentize installed. Currently it's disabled because it breaks
portability with standard LaTeX work flows, particularly my
collaborators don't know how to compile a tex file with this enabled.
It can be enables in each buffer by manually including the minted
package via "#+LATEX_HEADER: /usepackage{minted}"

#+BEGIN_SRC emacs-lisp
;; Add minted to the defaults packages to include when exporting.
;;(add-to-list 'org-latex-packages-alist '("" "minted" nil))

;; Tell the latex export to use the minted package for source code
;; coloration.
(setq org-latex-listings 'minted)

;; Let the exporter use the -shell-escape option to let latex execute
;; external programs. This obviously and can be dangerous to activate!
(setq org-latex-minted-options
      '(("mathescape" "true")
        ("linenos" "true")
        ("numbersep" "5pt")
        ("frame" "lines")
        ("framesep" "2mm")))
(setq org-latex-pdf-process
      '("latexmk -pdflatex='pdflatex --shell-escape' -pdf %f"))
#+END_SRC

**** Beamer back-end configuration
Beamer also needs some tweaks.

#+BEGIN_SRC emacs-lisp
(add-to-list  'org-beamer-environments-extra
              '("onlyenv" "O" "\\begin{onlyenv}%a" "\\end{onlyenv}"))

(add-to-list 'org-beamer-environments-extra
             '("textpos" "X" "\\begin{textblock}{10}(3,3) \\visible %a {" "} \\end{textblock}"))

(add-to-list 'org-beamer-environments-extra
             '("textpos1" "w" "\\begin{textblock}{%h}(3,3) \\visible %a {" "} \\end{textblock}"))
#+END_SRC

**** HTML back-end configuration
First disable emacs default style and include my own:
#+BEGIN_SRC emacs-lisp
(setq org-html-head-include-default-style nil)
(setq org-html-head
 "<link rel='stylesheet' href='http://gperaza.github.io/org.css' />")
#+END_SRC

*** Export behavior
I want to interpret "_" and "^" as sub and super indices only when
braces are used.

#+BEGIN_SRC emacs-lisp
(setq org-export-with-sub-superscripts '{})
#+END_SRC

If org-export-allow-bind-keywords is non-nil, Emacs variables can
become buffer-local during export by using the BIND keyword. Its
syntax is ‘#+BIND: variable value’. This is particularly useful for
in-buffer settings that cannot be changed using specific keywords.

#+BEGIN_SRC emacs-lisp
(setq org-export-allow-bind-keywords t)
#+END_SRC

Sometimes I want a header to be ignored but the content to be
exported, for this we activate ignore-headlines from ox-extra.
Now the tag "ignore" does just this.

#+BEGIN_SRC emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+END_SRC

** Org-ref
Org-ref is a fantastic package from John Kitchin to manage citations
and references in org-mode. It is worth it to read the whole
documentation (use command (org-ref-help) ).

Org-ref enables interactive cite links (cite), label links (label),

I use helm-bibtex for completion, so I load this first. We then load
org-ref.

#+BEGIN_SRC emacs-lisp
(use-package helm-bibtex
  :ensure t)

(use-package org-ref
  :ensure t)
#+END_SRC

Now some basic configuration that involves defining the location of
some files and key bindings. Insert cite link is "C-c ]" (default),
label link "C-c (", and ref link "C-c )". We define a key-chord "kk"
to access functions that act on a link.

#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "C-c (") 'org-ref-helm-insert-label-link)
(define-key org-mode-map (kbd "C-c )") 'org-ref-helm-insert-ref-link)
(key-chord-define-global "kk" 'org-ref-bibtex-hydra/body)
#+END_SRC

Org-ref already locate PDF files stored by Mendeley, but not for
Zotero, which I use. So I modified the function to seek for Mendeley
PDF files to work for Zotero (under a default configuration).

#+BEGIN_SRC emacs-lisp
(defun org-ref-get-zotero-filename (key)
  (let* ((results (org-ref-get-bibtex-key-and-file key))
         (bibfile (cdr results))
         entry)
    (with-temp-buffer
      (insert-file-contents bibfile)
      (bibtex-set-dialect (parsebib-find-bibtex-dialect) t)
      (bibtex-search-entry key nil 0)
      (setq entry (bibtex-parse-entry))
      (let ((e (org-ref-reftex-get-bib-field "file" entry)))
        (if (> (length e) 4)
            (let ((clean-field (replace-regexp-in-string "{\\|}\\|\\\\" "" e)))
              (let ((second-file (nth 1 (split-string clean-field ":" t))))
                (format "%s" second-file))))))))

(setq org-ref-get-pdf-filename-function 'org-ref-get-zotero-filename)
#+END_SRC

Org-ref gives an error on HTML export. I don't understand why, but It
is related to the function ~org-ref-make-org-link-cite-key-visible~ that
makes cites inside descriptive links correctly colored (I think). So
we remove the advice (This fix is ugly, let's hope it's fixed upstream.):

#+BEGIN_SRC emacs-lisp
(advice-remove 'org-activate-bracket-links
               #'org-ref-make-org-link-cite-key-visible)
#+END_SRC

** Templates
*** General purpose
This is a template for a research/project aid document. The purpose of
this document is to hold task, reading list, and some quick
notes. It's available using the "<paper" expansion.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             `("paper"
               ,(concat
                "#+TITLE:\n"
                "#+DATE:\n\n"
                "* Tasks\n\n"
                "** Writing\n\n"
                "** Model\n\n"
                "** Simulations\n\n"
                "* Reading\n\n"
                "** Actual reading\n\n"
                "** Should read\n\n"
                "** Not yet read\n\n"
                "** Already read\n\n"
                "* Notes\n"
                "Main notes are in the [[file:notes.org][notes]] file. "
                "Here lie some quick notes.\n\n"
                "* Files\n"
                "Links to relevant files to the research.\n\n"
                "* Meetings\n\n"
                "bibliography:")))
#+END_SRC

*** Code block templates
Templates for fast insertion of code blocks in org.
 - ~<p~ for python
 - ~<po~ for python with :results output
 - ~<pv~ for python with :results value output
 - ~<ip~ for ipython
 - ~<el~ for emacs-lisp
 - ~<sh~ for shell
 - ~<gp~ for gnuplot
 - ~<l~ for LaTeX

#+BEGIN_SRC emacs-lisp
;; add <p for python expansion
(add-to-list 'org-structure-template-alist
             '("p"
               "#+BEGIN_SRC python\n?\n#+END_SRC"
               "<src lang=\"python\">\n?\n</src>"))

;; add <por for python expansion with raw output
(add-to-list 'org-structure-template-alist
             '("po"
               "#+BEGIN_SRC python :results output raw\n?\n#+END_SRC"
               "<src lang=\"python\">\n?\n</src>"))

;; add <pv for python expansion with value
(add-to-list 'org-structure-template-alist
             '("pv"
               "#+BEGIN_SRC python :results value\n?\n#+END_SRC"
               "<src lang=\"python\">\n?\n</src>"))

;; add <ip for ipython expansion with session
(add-to-list 'org-structure-template-alist
             '("ip"
               "#+BEGIN_SRC ipython :session \n?\n#+END_SRC"
               "<src lang=\"python\">\n?\n</src>"))

;; add <el for emacs-lisp expansion
(add-to-list 'org-structure-template-alist
             '("el"
               "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"
               "<src lang=\"emacs-lisp\">\n?\n</src>"))

;; add <sh for shell
(add-to-list 'org-structure-template-alist
             '("sh"
               "#+BEGIN_SRC sh\n?\n#+END_SRC"
               "<src lang=\"shell\">\n?\n</src>"))

;; add <gp for gnuplot to file
(add-to-list 'org-structure-template-alist
             `("gp"
               ,(concat "#+BEGIN_SRC gnuplot :file ./Fig/plot_file.png\n"
                       "reset\n"
                       "set term pngcairo size 640,480\n"
                       "?\n"
                       "#+END_SRC\n"
                       "#+NAME: Plot name.\n"
                       "#+CAPTION: A plot.\n"
                       "#+RESULTS:\n")))

;; add <l for latex
(add-to-list 'org-structure-template-alist
             '("l"
               "#+BEGIN_LATEX latex\n?\n#+END_LATEX"
               "<src lang=\"latex\">\n?\n</src>"))
#+END_SRC

*** Blogging
This is post template. To create a blog post in it's own org file.
Accesses by ~<bpost~.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             `("bpost" ,(concat "#+TITLE: ?\n"
"#+DATE:\n"
"#+SUBTITLE: Posted:\n"
"# #+SUBTITLE: (/Last edited: {{{modification-time(%d %b %Y %H:%M)}}}/ )\n"
"#+AUTHOR: " user-full-name "\n"
"#+EMAIL: " user-mail-address "\n"
"#+LANGUAGE: en\n\n\n\n"
"* COMMENT local variables for this file
# Local Variables:
# eval: (setq system-time-locale \"en\")
# ispell-local-dictionary: \"en\"
# End:"
)))
#+END_SRC

This template creates a post preview. It's meant to be inserted in the
blog main page as a to-do heading. When the post is done mark is as
DONE to be published. Contains a summary of the post. Accessed by
~<bprev~.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             '("bprev" "* TODO ?
:DATES:
Posted:
# (/Edited: /)
:END:"))
#+END_SRC

** Blog using org publish
I publish my personal site using org-publish to create a static web
page that I then upload to Github.

*** Formatting functions and variables
This function removes brackets for time stamps.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-export-filter-timestamp-functions
             #'endless/filter-timestamp)

(defun endless/filter-timestamp (trans back _comm)
  "Remove <> around time-stamps."
  (pcase back
    ((or `jekyll `html)
     (replace-regexp-in-string "&[lg]t;" "" trans))
    (`latex
     (replace-regexp-in-string "[<>]" "" trans))))
#+END_SRC

Here I define the format for displaying time stamps.

#+BEGIN_SRC emacs-lisp
(setq-default org-display-custom-times t)

;;; Before you ask: No, removing the <> here doesn't work.
(setq org-time-stamp-custom-formats
      '("<%d %b %Y>" . "<%d/%m/%y %a %H:%M>"))
#+END_SRC

This function creates the bibliography HTML file that is included in
the Research page.

#+BEGIN_SRC emacs-lisp
(defun my-bibtex-function ()
  (shell-command-to-string
   (concat "bibtex2html -d -r -nobibsource -nokeywords "
           "-nf arxiv \"Arxiv\" --revkeys -nodoc "
           "-m ~/Blog/macros.tex -s ~/Blog/owens_web "
           "-noheader -nofooter ~/Blog/mypubs.bib; "
           "echo \"#+BEGIN_HTML\" > ~/Blog/mypubs.in; "
           "cat ~/Blog/mypubs.html >> ~/Blog/mypubs.in; "
           "echo  \"\" >> ~/Blog/mypubs.in; "
           "echo \"#+END_HTML\" >> ~/Blog/mypubs.in")))
#+END_SRC

This function is used to format a drawer in HTML export. It adds the
drawer name as a class.

#+BEGIN_SRC emacs-lisp
(defun my-blog-org-export-format-drawer (name content)
  (concat "<div class=\"drawer " (downcase name) "\">\n"
          content
          "\n</div>"))
#+END_SRC

*** Preamble and postamble
The preamble contains the navigation bar mainly.

The preamble for posts:

#+BEGIN_SRC emacs-lisp
(setq my-preamble-posts
      (concat
       "<a href=\"../index.html\"> HOME </a>\n|\n"
       "<a href=\"../blog.html\"> BLOG </a>\n |\n"
       "<a href=\"../teaching.html\"> TEACHING </a>\n|\n"
       "<a href=\"../research.html\"> RESEARCH </a>\n|\n"
       "<a href=\"../about.html\"> ABOUT ME </a>\n|\n"
       "<a href=\"archive.html\"> ARCHIVE </a>\n"
       ))
#+END_SRC

The preamble for pages:

#+BEGIN_SRC emacs-lisp
(setq my-preamble-pages
      (concat
       "<a href=\"index.html\"> HOME </a>\n|\n"
       "<a href=\"blog.html\"> BLOG </a>\n |\n"
       "<a href=\"teaching.html\"> TEACHING </a>\n|\n"
       "<a href=\"research.html\"> RESEARCH </a>\n|\n"
       "<a href=\"about.html\"> ABOUT ME </a>\n|\n"
       "<a href=\"posts/archive.html\"> ARCHIVE </a>\n"
       ))
#+END_SRC

The postamble contains author information and modification date, this
applies also for HTML export:

#+BEGIN_SRC emacs-lisp
(setq org-html-postamble t
        org-html-postamble-format
        '(("en" "<a class=\"author\"
           href=\"http://gperaza.github.org\">%a</a> / <span
           class=\"date\">%T</span><span class=\"creator\">%c</span>")))
#+END_SRC

*** Project configuration
#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :ensure t)
(setq org-html-htmlize-output-type 'css)
(setq org-publish-project-alist
      `(("blog"
         :components ("posts", "pages", "images", "css"))
        ("posts"
         :base-directory "~/Blog/posts/"
         :base-extension "org"
         :publishing-directory "~/Blog/pub/posts/"
         :recursive nil

         :publishing-function org-html-publish-to-html
         ;; :preparation-function
         ;; :completition-function

         :htmlized-source t

         :with-author t
         :with-creator t
         :with-date nil
         :with-email t
         :with-toc t

         :headline-level 4
         :section-numbers nil
         :html-validation-link nil

         :html-head "<link rel='stylesheet' href='../org.css' />"
         :html-head-include-default-style nil
         :html-head-include-scripts t
         :html-preamble ,my-preamble-posts

         :auto-sitemap t
         :sitemap-filename "archive"
         :sitemap-title "Blog archive"
         :sitemap-sort-files anti-chronologically
         :sitemap-file-entry-format "%t (Posted: %d)"
         :sitemap-date-format "%d %b %Y")
        ("pages"
         :base-directory "~/Blog/"
         :base-extension "org"
         :publishing-directory "~/Blog/pub/"
         :recursive nil

         :publishing-function org-html-publish-to-html
         :preparation-function my-bibtex-function
         ;; :completition-functiont
         :html-format-drawer-function my-blog-org-export-format-drawer

         :htmlized-source t

         :with-author t
         :with-creator t
         :with-date nil
         :with-email t
         :with-toc nil
         :with-tasks done
         :with-todo-keywords nil

         :headline-level 4
         :section-numbers nil
         :html-validation-link nil

         :html-head "<link rel='stylesheet' href='org.css' />"
         :html-head-include-default-style nil
         :html-head-include-scripts t
         :html-preamble ,my-preamble-pages)
        ("images"
         :base-directory "~/Blog/img/"
         :base-extension ".*"
         :publishing-directory "~/Blog/pub/img/"
         :publishing-function org-publish-attachment
         :recursive t)
        ("css"
         :base-directory "~/.dotfiles/css/"
         :base-extension "css"
         :publishing-directory "~/Blog/pub/"
         :publishing-function org-publish-attachment)
        ))
#+END_SRC

* Programming
** General configurations
*** Comments
#+BEGIN_SRC emacs-lisp
(defun comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode 1))
(add-hook 'prog-mode-hook 'comment-auto-fill)

(use-package comment-dwim-2
  :ensure t
  :config
  (global-set-key (kbd "M-;") 'comment-dwim-2))
#+END_SRC

*** Display function name in the mode line
#+BEGIN_SRC emacs-lisp
(which-function-mode 1)
#+END_SRC

*** Highlight comment annotations
#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :ensure t
  :config (add-hook 'prog-mode-hook 'hl-todo-mode))
#+END_SRC

*** Flycheck
Setup flychek with a helm.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :config (global-flycheck-mode 1))

(use-package flycheck-pos-tip
  :ensure t
  :config
  (with-eval-after-load 'flycheck
    (flycheck-pos-tip-mode)))

(use-package helm-flycheck
  :ensure t
  :config
  (define-key flycheck-mode-map (kbd "C-c ! h") 'helm-flycheck))
#+END_SRC

**** Proselint
Makes Emacs too too slow in large buffers
#+BEGIN_SRC emacs-lisp
(flycheck-define-checker proselint
  "A linter for prose."
  :command ("proselint" source-inplace)
  :error-patterns
  ((warning line-start (file-name) ":" line ":" column ": "
        (id (one-or-more (not (any " "))))
        (message) line-end))
  :modes (text-mode markdown-mode gfm-mode latex-mode org-mode))

;; (add-to-list 'flycheck-checkers 'proselint)
#+END_SRC

*** Rainbow delimiters, colors parenthesis
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :config
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'org-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

*** Line numbers
#+BEGIN_SRC emacs-lisp
(use-package nlinum
  :ensure t
  :config
  (add-hook 'python-mode-hook 'nlinum-mode))
#+END_SRC

*** Speedbar
#+BEGIN_SRC emacs-lisp
(use-package sr-speedbar
  :ensure t
  :config
  (global-set-key (kbd "s-s") 'sr-speedbar-toggle))
#+END_SRC

*** Origami for folding
#+BEGIN_SRC emacs-lisp
(use-package origami
  :ensure t
  :config
  (define-key origami-mode-map (kbd "C-<tab>")
    'origami-recursively-toggle-node)
  (define-key origami-mode-map (kbd "S-<iso-lefttab>")
    'origami-toggle-all-nodes)
  (add-hook 'c-mode-common-hook 'origami-mode)
  (add-hook 'python-mode-hook 'origami-mode)
  )
#+END_SRC

*** Clean-aindent-mode
#+BEGIN_SRC emacs-lisp
(use-package clean-aindent-mode
  :ensure t
  :config
  (add-hook 'prog-mode-hook 'clean-aindent-mode)
  (define-key prog-mode-map (kbd "RET") 'newline-and-indent))
#+END_SRC

** Semantic mode
Semantic mode enables parsing of source code files.
#+BEGIN_SRC emacs-lisp
(require 'semantic)

(global-semanticdb-minor-mode 1)
(global-semantic-idle-scheduler-mode 1)
(global-semantic-idle-summary-mode 1)
(use-package stickyfunc-enhance
  :ensure t
  :config (global-semantic-stickyfunc-mode 1))

(setq helm-semantic-fuzzy-match t
      helm-imenu-fuzzy-match    t)
(semantic-mode 1)
#+END_SRC

** Projectile
Project management for emacs. See
https://github.com/bbatsov/projectile.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :init (setq projectile-use-git-grep t)
  :config
  (projectile-global-mode)
  (setq projectile-completion-system 'helm))

(use-package helm-projectile
  :ensure t
  :config (helm-projectile-on)
  (setq projectile-switch-project-action 'helm-projectile))
#+END_SRC

** Yasnippet
#+BEGIN_SRC emacs-lisp
;; (use-package yasnippet
;;   :ensure t
;;   :config
;;   (yas-reload-all)
;;   (define-key yas-minor-mode-map (kbd "<tab>") nil)
;;   (define-key yas-minor-mode-map (kbd "TAB") nil)
;;   (define-key yas-minor-mode-map (kbd "<C-S-iso-lefttab>") 'yas-expand)
;;   (add-hook 'c-mode-common-hook #'yas-minor-mode)
;;   (add-hook 'LaTeX-mode-hook #'yas-minor-mode)
;;   )
#+END_SRC

** Python
Install elpy package from the *elpy repository*.
#+BEGIN_SRC emacs-lisp
(elpy-enable)
(setq elpy-rpc-backend "jedi")
(elpy-use-ipython)
(setq elpy-modules (delete 'elpy-module-flymake elpy-modules))
(add-hook 'python-mode-hook
          (lambda () (set (make-local-variable 'comment-inline-offset) 2)))
;; (set-face-background 'highlight-indentation-face "#e3e3d3")
;; (set-face-background 'highlight-indentation-current-column-face "#c3b3b3")
(setq elpy-rpc-error-timeout 100000000)
#+END_SRC

** C
#+BEGIN_SRC emacs-lisp
(setq-default c-basic-offset 4)
(require 'cc-mode)

;; New functions
(define-key c-mode-base-map (kbd "M-q") 'sp-indent-defun)
(define-key c-mode-base-map (kbd "RET") 'newline-and-indent)

;; Format to display tags
(with-eval-after-load 'helm-semantic
  (push '(c-mode . semantic-format-tag-summarize) helm-semantic-display-style)
  (push '(c++-mode . semantic-format-tag-summarize)
        helm-semantic-display-style))

;; c99 mode
(defun my-flycheck-c-setup ()
  (setq flycheck-gcc-language-standard "gnu99"))
(add-hook 'c-mode-hook #'my-flycheck-c-setup)
#+END_SRC

** Gnuplot
#+BEGIN_SRC emacs-lisp
(use-package gnuplot
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.gp\\'" . gnuplot-mode))
  )
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t)
(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.text\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
#+END_SRC

** Processing
#+BEGIN_SRC emacs-lisp
(use-package processing-mode
  :ensure t
  :config
  (setq processing-location "/home/gperaza/processing/processing-java")
  (setq processing-application-dir "/home/gperaza/processing")
  (setq processing-sketchbook-dir "/home/gperaza/Documents/code/processing"))
#+END_SRC

** Fish-shell
#+BEGIN_SRC emacs-lisp
(use-package fish-mode
  :ensure t)
#+END_SRC
